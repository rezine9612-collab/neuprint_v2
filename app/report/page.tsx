"use client";

import { useEffect, useMemo } from "react";
import { runReportV3 } from "@/lib/client/report/report_v3";

export default function ReportPage() {
  const reportHtml = useMemo(
    () => ({ __html: "\n<div id=\"npReportRoot\">\n\n    <!-- Header -->\n    <header class=\"topbar\" id=\"topbar\">\n      <div class=\"container\">\n        <div class=\"headerTopRow\">\n          <div class=\"headerLeft\">\n            <div class=\"headerBrand\">\n              <img alt=\"NeuPrint Logo\" class=\"brandLogo\" src=\"./neuprint_logo.svg\" />\n            </div>\n            <div class=\"brandline\">\n              <span> NeuPrint Cognitive Forensics Engine v1.1 </span>\n            </div>\n          </div>\n          <div class=\"headerRight rightMeta\" id=\"qrBlock\">\n            <div class=\"verifyText\" id=\"verifyText\">\n              This determination is structurally signed and referenceable.\n              <br />\n              <span id=\"verifyUrlText\"></span>\n              <br />\n              <br />\n              QR code shown represents the verification anchor.\n              <br />\n              Verification ID :\n              <span id=\"verifyIdText\"></span>\n            </div>\n            <div class=\"qrBox\" title=\"QR image\">\n              <img\n                alt=\"QR placeholder\"\n                id=\"qrImg\"\n                src=\"https://upload.wikimedia.org/wikipedia/commons/d/d0/QR_code_for_mobile_English_Wikipedia.svg\"\n              />\n            </div>\n          </div>\n        </div>\n        <div class=\"headerBelowRow\">\n          <h1 class=\"title\" id=\"heroTitle\"></h1>\n          <p class=\"subtitle\" id=\"heroDesc\"></p>\n          <div class=\"metaRow\">\n            <span class=\"chip\">\n              <span class=\"chipLabel\"> RSL Level </span>\n              <span class=\"pill toneB\" id=\"rslPill\"></span>\n            </span>\n            <span class=\"chip\" title=\"Final determination label\">\n              <span class=\"chipLabel\"> Determination </span>\n              <span class=\"pill toneE\" id=\"finalDetPill\"></span>\n            </span>\n            <span\n              class=\"chip\"\n              title=\"Reasoning Index (uses the same 0\u20135 axis shown in the placement map)\"\n            >\n              <span class=\"chipLabel\"> FRI </span>\n              <span class=\"pill toneC\" id=\"reasoningIndexPill\"></span>\n            </span>\n            <span class=\"chip\" title=\"Structural agency share\">\n              <span class=\"chipLabel\"> Control </span>\n              <span class=\"pill toneN\" id=\"controlPill\"></span>\n            </span>\n            <span class=\"chip\" title=\"Top recommended role track\">\n              <span class=\"chipLabel\"> Role Fit </span>\n              <span class=\"pill toneD\" id=\"jobFitPill\"></span>\n            </span>\n          </div>\n          <!-- Decision-Grade Cognitive Compression -->\n          <div class=\"decisionCompression\">\n            <div class=\"decisionCompressionLine\"><span id=\"heroDecisionQuote\"></span></div>\n          </div>\n        </div>\n      </div>\n    </header>\n    <div class=\"container\">\n      <!-- 3. Reasoning Control (Structural Agency) -->\n      <section class=\"grid\" id=\"tab-rsl\">\n        <div class=\"card\">\n          <div class=\"sectionBlock\">\n            <div class=\"cardHeader\">\n              <div class=\"cardTitle\">1. Reasoning Structure Layer (RSL)</div>\n            </div>\n            <div class=\"tiny muted uNoteTight2\">\n              This section shows how your thinking was organized in this writing, and what you can improve next.\n            </div>\n            <!-- A) Single-line section purpose (student-friendly) -->\n            <div class=\"tiny muted uNoteTight\"></div>\n            <div class=\"metrics uMb8\">\n              <div class=\"metricBox\">\n                <div class=\"metricLabel\">RSL Level</div>\n                <div class=\"metricValue\" id=\"mRslLevel\"></div>\n                <div class=\"metricNote\" id=\"mRslLevelNote\"></div>\n              </div>\n              <div class=\"metricBox\">\n                <div class=\"metricLabel\">Final Reasoning Index</div>\n                <div class=\"metricValue\" id=\"mRslMean\"></div>\n                <div class=\"metricNote\" id=\"mRslMeanNote\"></div>\n              </div>\n              <div class=\"metricBox\">\n                <div class=\"metricLabel\">Cohort Placement</div>\n                <div class=\"metricValue\" id=\"mRslCohort\"></div>\n                <div class=\"metricNote\" id=\"mRslCohortNote\"></div>\n              </div>\n              <div class=\"metricBox\">\n                <div class=\"metricLabel\">Stability Index</div>\n                <div class=\"metricValue\" id=\"mRslStability\"></div>\n                <div class=\"metricNote\" id=\"mRslStabilityNote\"></div>\n              </div>\n            </div>\n            <!-- C) Summary -->\n            <div class=\"uMt14\">\n              <div class=\"panel\">\n                <div class=\"small\">RSL Summary</div>\n                <div id=\"rsl_one_line_summary\" class=\"rslOneLine\">\n                  <span id=\"rslOneLine\"></span>\n                </div>\n                <div class=\"tiny muted uMt0\" id=\"rslSummaryText\"></div>\n              </div>\n            </div>\n            <!-- D) Charts -->\n            <div class=\"twoCol uMt14\">\n              <!-- (LEFT) Cohort Positioning (replaces RSL Dimension Bars) -->\n              <div class=\"chartBox\">\n                <div class=\"chartTitleText\">Cohort Positioning</div>\n                <div class=\"chartCanvasWrap chartCohortWrap\">\n                  <canvas id=\"chartRslBars\"> </canvas>\n                </div>\n                <div class=\"tiny muted uMt10\">\n                  Horizontal axis shows FRI (0 to 5). Vertical axis shows the share of the cohort (0\n                  to 100%) at each score band. The yellow marker shows the current position, and the\n                  outer ring indicates the positioning moment.\n                </div>\n              </div>\n              <!-- (RIGHT) RSL Radar (unchanged) -->\n              <div class=\"chartBox radarBox\">\n                <div class=\"chartTitleText\">RSL Radar</div>\n                <div class=\"chartCanvasWrap\">\n                  <canvas id=\"chartRslRadar\"> </canvas>\n                </div>\n                <div class=\"tiny muted uMt10\">\n                  This chart shows balance. A rounder shape means your skills work together. Sharp\n                  dips mean one or two skills need attention.\n                </div>\n              </div>\n            </div>\n            <!-- E) Dimension Results -->\n            <div class=\"panel uMt14\">\n              <div class=\"small\">Reasoning by Dimension</div>\n              <!-- \u2705 \uc5ec\uae30(\uc774 \uc904)\uc5d0 arcTableFrame \"\uc5ec\ub294 div\"\ub97c \ub123\ub294\ub2e4 -->\n              <div class=\"arcTableFrame tableFrame\">\n                <table>\n                  <thead>\n                    <tr>\n                      <th class=\"uW220\">Reasoning Dimension</th>\n                      <th class=\"uW110\">Score</th>\n                      <th>Structural Observation</th>\n                    </tr>\n                  </thead>\n                  <tbody id=\"rslResultsByDimension\">\n                    <!-- rows injected from DEV JSON -->\n                  </tbody>\n                </table>\n                <div class=\"tiny muted uTopRule\">\n                  RSL (R1\u2013R8) is aligned with internationally validated reasoning constructs used\n                  across OECD/PISA assessments, ETS evidence-centered evaluation frameworks,\n                  APA-endorsed critical thinking models, and UNESCO-referenced global competence and\n                  citizenship frameworks.\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </section>\n      <section class=\"grid\" id=\"tab-cff\">\n        <div class=\"card\">\n          <div class=\"sectionBlock\">\n            <div class=\"cardHeader\">\n              <div class=\"cardTitle\">2. Cognitive Fingerprint Framework (CFF)</div>\n            </div>\n            <div class=\"tiny muted uNoteTight2\">\n              Describes structural characteristics of reasoning formation and revision behavior\n              observed in the task, based on the CFF indicator set.\n            </div>\n            <div class=\"twoCol\">\n              <!-- LEFT : Observed Reasoning Patterns -->\n              <div class=\"panel\">\n                <div class=\"small\">Observed Reasoning Patterns</div>\n                <!-- Result line -->\n                <div class=\"tiny muted uMt8Lh\">\n                  Primary pattern is <span class=\"kpiLabel\" id=\"cffPrimary\"></span> and secondary\n                  pattern is <span class=\"kpiLabel\" id=\"cffSecondary\"></span>.\n                </div>\n                <!-- Middle: grey card -->\n                <div class=\"kpiRow uMt12\">\n                  <span class=\"kpi\"><span class=\"kpiLabel\" id=\"cffPrimary2\"></span></span>\n\t\t\t\t  <span class=\"kpi\"><span class=\"kpiLabel\" id=\"cffSecondary2\"></span></span>\n                </div>\n                <!-- Bottom: explanation (meaning) -->\n                <div class=\"tiny muted uMt8Lh\" id=\"cffPatternMeaning\"></div>\n              </div>\n              <!-- RIGHT : Final Determination -->\n              <div class=\"panel\">\n                <div class=\"small\">Final Determination</div>\n                <!-- Friendly intro -->\n                <div class=\"tiny muted uMt6Lh\">Based on the observed reasoning patterns and structural control signals, the reasoning is classified as :</div>\n                <!-- Middle: grey card -->\n                <div class=\"kpiRow uMt12\">\n                  <span class=\"kpi\"><span class=\"kpiLabel\" id=\"cffFinalLabel2\"></span></span>\n\t\t\t\t  <span class=\"kpi\"><span class=\"kpiLabel\">Type Confidence : </span><span class=\"code\" id=\"cffFinalConf2\"></span></span>\n                </div>\n                <!-- Bottom: explanation (meaning) -->\n                <div class=\"tiny muted uMt8Lh\" id=\"cffFinalMeaning\"></div>\n              </div>\n\n            </div>\n            <div class=\"twoCol\">\n              <!-- Signature -->\n              <div class=\"chartBox signatureBox\" id=\"signatureBox\">\n                <div class=\"chartTitleText\">Cognitive Fingerprint</div>\n                <div class=\"chartCanvasWrap\" id=\"signatureWrap\">\n                  <canvas aria-label=\"Cognitive fingerprint canvas\" id=\"signatureCanvas\"> </canvas>\n                </div>\n                <div class=\"tiny muted centerTiny\">\n                  <span class=\"kpiLabel\"> Reasoning Structure Visualization </span>\n                </div>\n                <div class=\"tiny muted uLh155\" id=\"signatureNote\"></div>\n              </div>\n              <!-- Radar -->\n              <div class=\"chartBox radarBox\">\n                <div class=\"chartTitleText\">CFF Radar</div>\n                <div class=\"chartCanvasWrap\">\n                  <canvas id=\"chartCffRadar\"> </canvas>\n                </div>\n                <div class=\"tiny muted uMt10\">\n                  The CFF Radar shows the relative distribution of structural reasoning indicators.\n                  The shape reflects contribution patterns rather than performance or optimality.\n                </div>\n              </div>\n            </div>\n            <div class=\"panel uMt14\">\n              <div class=\"small\">CFF Indicator Summary</div>\n              <div class=\"tableFrame\">\n                <table>\n                  <thead>\n                    <tr>\n                      <th class=\"uW120\">Code</th>\n                      <th class=\"uW140\">Score</th>\n                      <th>Indicator</th>\n                      <th class=\"uW160\">Status</th>\n                    </tr>\n                  </thead>\n                  <tbody id=\"cffTableBody\"></tbody>\n                </table>\n              </div>\n              <div class=\"tiny muted uMt10Lh\">\n                The Cognitive Fingerprint Framework describes how reasoning is structurally formed,\n                revised, and controlled, providing a stable reference for understanding thinking\n                patterns beyond surface content or outcomes.\n              </div>\n            </div>\n          </div>\n        </div>\n      </section>\n      <section class=\"grid\" id=\"tab-authorship\">\n        <div class=\"card\">\n          <div class=\"sectionBlock\">\n            <div class=\"cardHeader\">\n              <div class=\"cardTitle\">3. Reasoning Control (Structural Agency)</div>\n            </div>\n            <div class=\"tiny muted uNoteTight2\">\n              Evaluates individual control over reasoning decisions versus automated continuation,\n              as defined by structural agency at decision boundaries in NeuPrint.\n            </div>\n            <!-- \uc0c1\ub2e8 \ud328\ub110 -->\n            <div class=\"twoCol\">\n              <!-- LEFT -->\n              <div class=\"panel\">\n                <div class=\"small\">Reasoning Control Summary</div>\n                <div class=\"tiny muted uMt6\" id=\"aiInterpretation\"></div>\n                <div class=\"kpiRow uMt10\">\n                  <span class=\"kpi\">\n                    <span class=\"kpiLabel\"> Control pattern : </span>\n                    <span class=\"code\" id=\"aiPatternLabel\"></span>\n                  </span>\n                  <span class=\"kpi\">\n                    <span class=\"kpiLabel\"> Reliability band : </span>\n                    <span class=\"code\" id=\"aiReliability\"></span>\n                  </span>\n                </div>\n                <div class=\"tiny muted uMt10Lh\">\n                  Reasoning decisions originate from human-driven structural revision rather than\n                  automated continuation flow.\n                </div>\n              </div>\n              <!-- RIGHT -->\n              <div class=\"panel\">\n                <div class=\"small\">Observed Structural Signals</div>\n                <ul class=\"tiny muted uListTight\" id=\"agencySignalsList\">\n                  <!-- injected from report data -->\n                </ul>\n                <div class=\"tiny muted uMt10Lh\" id=\"agencySignalsNote\">\n                  These signals reflect document-specific structural behavior and are independent of\n                  surface-level writing style.\n                </div>\n              </div>\n            </div>\n            <!-- \ud558\ub2e8 \ucc28\ud2b8 -->\n            <div class=\"twoCol uMt12\">\n              <!-- Distribution -->\n              <div class=\"chartBox distBar\">\n                <div class=\"chartTitleText\">Reasoning Control Distribution</div>\n                <div class=\"chartCanvasWrap uH140\">\n                  <canvas id=\"chartMixAgency\"> </canvas>\n                </div>\n                <div class=\"tiny muted uMt10Lh\">\n                  The distribution shows the proportion of ownership of reasoning decisions across\n                  structural decision points. Values reflect where control was exercised during\n                  reasoning transitions, not authorship attribution, model usage, or stylistic\n                  origin. A high human proportion indicates that primary reasoning control remained\n                  with the individual throughout the task.\n                </div>\n                <div class=\"kpiRow uMt6\" id=\"mixKpis\"></div>\n              </div>\n              <!-- Structural Signals -->\n              <div class=\"chartBox\">\n                <div class=\"chartTitleText\">\n                  Structural Control Signals\n                  <span class=\"tiny muted\"> (Agency Indicators) </span>\n                </div>\n                <div class=\"chartCanvasWrap\">\n                  <canvas id=\"chartAuthSignals\"> </canvas>\n                </div>\n                <div class=\"tiny muted uMt10Lh\">\n                  Signal values represent relative contribution to the overall reasoning control\n                  determination, normalized on a 0 to 1 scale.\n                </div>\n                <ul class=\"tiny muted uListTight2\">\n                  <li>\n                    <span class=\"kpiLabel\"> Structural variance </span>\n                    : non-linear restructuring across reasoning boundaries.\n                  </li>\n                  <li>\n                    <span class=\"kpiLabel\"> Human rhythm index </span>\n                    : irregular pacing consistent with reflective decision cycles.\n                  </li>\n                  <li>\n                    <span class=\"kpiLabel\"> Transition flow </span>\n                    : intentional movement between reasoning states.\n                  </li>\n                  <li>\n                    <span class=\"kpiLabel\"> Revision depth </span>\n                    : degree of conceptual modification at semantic boundaries.\n                  </li>\n                </ul>\n                <div class=\"tiny muted uMt10Lh\">\n                  The combined signal profile supports classification as human-controlled reasoning.\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </section>\n      <section class=\"grid\" id=\"tab-hr\">\n        <div class=\"card\">\n          <div class=\"sectionBlock\">\n            <div class=\"cardHeader\">\n              <div class=\"cardTitle\">4. Role Fit Signals</div>\n            </div>\n            <div class=\"tiny muted uNoteTight2\">\n              Explores alignment between observed reasoning patterns and role-specific cognitive\n              demands.\n            </div>\n            <!-- Combined layout: left column (summary + fit), right column (vertical inference flow) -->\n            <div class=\"twoCol roleFitGrid\">\n              <!-- LEFT: Summary + Fit chart -->\n              <div class=\"roleFitLeftCol\">\n                <div class=\"panel\">\n                  <div class=\"small\">Cognitive Style Summary</div>\n                  <div class=\"tiny muted uMt6\" id=\"hrProfile1\"></div>\n                  <div class=\"kpiRow uMt10\" id=\"hrKpis\"></div>\n                  <div class=\"tiny muted uMt11\" id=\"hrProfile2\"></div>\n                </div>\n                <div class=\"chartBox\">\n                  <div class=\"chartTitleText\">Job Role Fit</div>\n                  <div class=\"chartCanvasWrap\">\n                    <canvas id=\"chartHrFit\"> </canvas>\n                  </div>\n                  <div class=\"tiny muted uMt6\" id=\"hrProfile3\"></div>\n                </div>\n              </div>\n              <!-- RIGHT: Role fit inference flow (replaces coaching boxes + chart) -->\n              <div class=\"panel roleFitRightCol\">\n                <div class=\"small\">Role Fit Inference Flow</div>\n                \n                <div class=\"rfFlow is-animated\" aria-label=\"Role Fit Inference Flow\">\n                  <div class=\"rfRow r1\" data-step=\"1\">\n                    <div class=\"rfMark\" aria-hidden=\"true\"><span class=\"rfStep\"></span></div>\n                    <div class=\"rfText\">\n                      <div class=\"rfTitle\">Cognitive Operating Characteristics</div>\n                      <div class=\"rfTags\">thought control \u00b7 reasoning mode</div>\n                    </div>\n                  </div>\n\n                  <div class=\"rfRow r2\" data-step=\"2\">\n                    <div class=\"rfMark\" aria-hidden=\"true\"><span class=\"rfStep\"></span></div>\n                    <div class=\"rfText\">\n                      <div class=\"rfTitle\">Reasoning Structure Patterns</div>\n                      <div class=\"rfTags\">decomposition \u00b7 linkage \u00b7 validation \u00b7 regulation</div>\n                    </div>\n                  </div>\n\n                  <div class=\"rfRow r3\" data-step=\"3\">\n                    <div class=\"rfMark\" aria-hidden=\"true\"><span class=\"rfStep\"></span></div>\n                    <div class=\"rfText\">\n                      <div class=\"rfTitle\">NeuPrint Primary Metrics</div>\n                      <div class=\"rfTags\">CFF 8 \u00b7 RSL R1\u2013R8</div>\n                    </div>\n                  </div>\n\n                  <div class=\"rfRow r4\" data-step=\"4\">\n                    <div class=\"rfMark\" aria-hidden=\"true\"><span class=\"rfStep\"></span></div>\n                    <div class=\"rfText\">\n                      <div class=\"rfTitle\">NeuPrint Secondary Interpretations</div>\n                      <div class=\"rfTags\">Reasoning Level \u00b7 Stability \u00b7 Drift</div>\n                    </div>\n                  </div>\n\n                  <div class=\"rfRow r5\" data-step=\"5\">\n                    <div class=\"rfMark\" aria-hidden=\"true\"><span class=\"rfStep\"></span></div>\n                    <div class=\"rfText\">\n                      <div class=\"rfTitle\">Competency Fulfillment Assessment</div>\n                      <div class=\"rfTags\">OECD aligned \u00b7 O*NET aligned \u00b7 reference</div>\n                    </div>\n                  </div>\n\n                  <div class=\"rfRow r6\" data-step=\"6\">\n                    <div class=\"rfMark\" aria-hidden=\"true\"><span class=\"rfStep\"></span></div>\n                    <div class=\"rfText\">\n                      <div class=\"rfTitle\">Job Role Fit</div>\n                      <div class=\"rfTags\">final alignment signal \u00b7 decision support</div>\n                    </div>\n                  </div>\n                </div>\n\n                <!-- Role Fit closing statement (data-bound) -->\n                <div class=\"tiny muted uMt10\" id=\"rfClosing\"></div>\n\n            </div>\n          </div>\n        </div>\n      </section>\n      <!-- International Framework Alignment (logos, grayscale) -->\n      <div aria-label=\"International framework alignment\" class=\"alignmentStrip\">\n        <div class=\"alignmentInner\">\n          <div aria-label=\"Aligned institutions and frameworks\" class=\"alignmentLogos\">\n            <div class=\"alLogo\">\n              <img alt=\"OECD\" class=\"alImg\" src=\"OECD_logo.png\" />\n              <span class=\"alFallback\"> OECD </span>\n            </div>\n            <div class=\"alLogo\">\n              <img alt=\"PISA\" class=\"alImg\" src=\"PISA_logo.png\" />\n              <span class=\"alFallback\"> PISA </span>\n            </div>\n            <div class=\"alLogo\">\n              <img alt=\"ETS\" class=\"alImg\" src=\"ETS_logo.png\" />\n              <span class=\"alFallback\"> ETS </span>\n            </div>\n            <div class=\"alLogo\">\n              <img alt=\"APA\" class=\"alImg\" src=\"APA_logo.png\" />\n              <span class=\"alFallback\"> APA </span>\n            </div>\n            <div class=\"alLogo\">\n              <img alt=\"O*NET\" class=\"alImg\" src=\"Onet_logo.png\" />\n              <span class=\"alFallback\"> O*NET </span>\n            </div>\n            <div class=\"alLogo\">\n              <img alt=\"AERA\" class=\"alImg\" src=\"AERA_logo.png\" />\n              <span class=\"alFallback\"> AERA </span>\n            </div>\n            <div class=\"alLogo\">\n              <img alt=\"NCME\" class=\"alImg\" src=\"NCME_logo.png\" />\n              <span class=\"alFallback\"> NCME </span>\n            </div>\n            <div class=\"alLogo\">\n              <img alt=\"AAC&amp;U\" class=\"alImg\" src=\"AACU_logo.png\" />\n              <span class=\"alFallback\"> AAC&amp;U </span>\n            </div>\n            <div class=\"alLogo\">\n              <img alt=\"Cambridge\" class=\"alImg\" src=\"Cambridge_logo.png\" />\n              <span class=\"alFallback\"> Cambridge </span>\n            </div>\n            <div class=\"alLogo\">\n              <img alt=\"IB\" class=\"alImg\" src=\"IB_logo.png\" />\n              <span class=\"alFallback\"> IB </span>\n            </div>\n            <div class=\"alLogo\">\n              <img alt=\"LSAT\" class=\"alImg\" src=\"LSAT_logo.png\" />\n              <span class=\"alFallback\"> LSAT </span>\n            </div>\n            <div class=\"alLogo\">\n              <img alt=\"GMAT\" class=\"alImg\" src=\"GMAT_logo.png\" />\n              <span class=\"alFallback\"> GMAT </span>\n            </div>\n          </div>\n          <div class=\"alignmentNote\">\n            NeuPrint\u2019s cognitive frameworks and rubrics are structurally aligned with\n            <span class=\"em\"> internationally recognized assessment and competency systems </span>\n            .\n            <br />\n            These include\n            <span class=\"em\"> OECD PISA </span>\n            ,\n            <span class=\"em\"> ETS measurement models </span>\n            ,\n            <span class=\"em\"> AERA and NCME evaluation standards </span>\n            , and\n            <span class=\"em\"> AAC&amp;U VALUE rubrics </span>\n            .\n            <br />\n            They also reflect shared reasoning constructs found in\n            <span class=\"em\"> Cambridge International </span>\n            , the\n            <span class=\"em\"> International Baccalaureate (IB) </span>\n            , and reasoning assessments such as the\n            <span class=\"em\"> LSAT and GMAT </span>\n            .\n          </div>\n        </div>\n      </div>\n      <div class=\"footer\">\n        <div>Copyright \u00a9 2026 Neuprint. All rights reserved.</div>\n        <div>U.S. entity in formation.</div>\n      </div>\n    </div>\n<script>\n(function(){\n  if(!document.documentElement.classList.contains('npReport-scope')) return;\n\n      /* ================================\n     \ubaa8\ubc14\uc77c \ud310\ubcc4 + \ub51c\ub808\uc774 \uac12 (\ub9e8 \uc704!)\n  ================================ */\n      const IS_MOBILE = window.matchMedia('(max-width: 680px)').matches\n      const MOBILE_CHART_START_DELAY = 10\n      const NP_DEBUG = false\n      /* =========================================================\n     RSL table responsive behavior (reversible)\n     - Mobile: show observation under Dimension, keep Score column\n              and display \"Score 4\" right-aligned.\n     - Desktop: restore original 3-column table.\n     Why: the previous mobile transform was destructive (removed cells)\n          so resizing back to desktop could not recover.\n  ========================================================= */\n      function __np_setArcTableLayout() {\n        try {\n          const isMobile = window.matchMedia('(max-width: 680px)').matches\n          const tbody = document.getElementById('rslResultsByDimension')\n          if (!tbody) return\n\n          const rows = Array.from(tbody.querySelectorAll('tr'))\n          rows.forEach((tr) => {\n            if (!tr.dataset.npArcOrig) {\n              tr.dataset.npArcOrig = tr.innerHTML\n            }\n\n            if (isMobile) {\n              if (tr.dataset.npArcMode === 'mobile') return\n              tr.innerHTML = tr.dataset.npArcOrig\n\n              const tds = tr.querySelectorAll('td')\n              if (tds.length < 3) {\n                tr.dataset.npArcMode = 'mobile'\n                return\n              }\n\n              const dimTd = tds[0]\n              const scoreTd = tds[1]\n              const obsTd = tds[2]\n\n              const dimText = (dimTd.textContent || '').trim()\n              const scoreText = (scoreTd.textContent || '').trim()\n              const obsText = (obsTd.textContent || '').trim()\n\n              dimTd.colSpan = 2\n              scoreTd.remove()\n\n              dimTd.innerHTML = ''\n\n              const head = document.createElement('div')\n              head.className = 'arcHeadLine'\n\n              const label = document.createElement('span')\n              label.className = 'arcDimLabel'\n              label.textContent = dimText\n\n              const scoreWrap = document.createElement('span')\n              scoreWrap.className = 'arcScoreWrap'\n\n              const scoreWord = document.createElement('span')\n              scoreWord.className = 'arcScoreWord'\n              scoreWord.textContent = 'Score '\n\n              const scoreDot = document.createElement('span')\n              scoreDot.className = 'arcScoreDot'\n              scoreDot.textContent = scoreText\n\n              scoreWrap.appendChild(scoreWord)\n              scoreWrap.appendChild(scoreDot)\n\n              head.appendChild(label)\n              head.appendChild(scoreWrap)\n              dimTd.appendChild(head)\n\n              if (obsText) {\n                const obs = document.createElement('div')\n                obs.className = 'arcObsMobile'\n                obs.textContent = obsText\n                dimTd.appendChild(obs)\n              }\n\n              obsTd.textContent = obsText\n\n              tr.dataset.npArcMode = 'mobile'\n            } else {\n              if (tr.dataset.npArcMode === 'desktop' || !tr.dataset.npArcOrig) return\n              tr.innerHTML = tr.dataset.npArcOrig\n              tr.dataset.npArcMode = 'desktop'\n            }\n          })\n        } catch (e) {\n          NP_DEBUG && console.warn('[NeuPrint] RSL responsive layout failed:', e)\n        }\n      }\n      window.addEventListener(\n        'resize',\n        () => {\n          __np_setArcTableLayout()\n        },\n        { passive: true },\n      )\n      window.addEventListener(\n        'orientationchange',\n        () => {\n          __np_setArcTableLayout()\n        },\n        { passive: true },\n      )\n      \n\n      /* =========================================================\n         Role Fit Inference Flow (1~6)\n         - Start animation ONLY when #tab-hr enters viewport\n         - Run ONCE (no repeat on scroll)\n         - Enforce strict 1\u21926 sequential delays\n      ========================================================= */\n      function __np_initRoleFitFlowOnView(){\n        try{\n          const sec = document.getElementById('tab-hr');\n          const flow = sec ? sec.querySelector('.rfFlow.is-animated') : null;\n          if(!sec || !flow) return;\n\n          // Prepare deterministic per-row delays (do NOT start yet)\n          const rows = Array.from(flow.querySelectorAll('.rfRow'));\n          // Use CSS variable if present, otherwise fallback to existing defaults\n          const baseDelay = 210; // ms between boxes (2x faster) // ms between boxes (already doubled vs earlier)\n          rows.forEach((row, i)=>{\n            row.style.animationDelay = (i*baseDelay) + 'ms';\n          });\n\n          // Safety: ensure not started by default\n          flow.classList.remove('rf-start');\n\n          // Start once when visible\n          let started = false;\n          const start = ()=>{\n            if(started) return;\n            started = true;\n            flow.classList.add('rf-start');\n          };\n\n          if('IntersectionObserver' in window){\n            const io = new IntersectionObserver((entries)=>{\n              for(const e of entries){\n                if(e.isIntersecting){\n                  start();\n                  io.disconnect();\n                  break;\n                }\n              }\n            },{ root:null, threshold:0.12, rootMargin:'0px 0px -10% 0px' });\n            io.observe(flow);\n          }else{\n            // Fallback: start after 1s delay\n            window.setTimeout(()=>{ start(); }, 0);\n          }\n        }catch(e){\n          // keep silent in production\n        }\n      }\nwindow.renderNeuPrint = function (reportObject) {\n        'use strict'\n\n        const NP_DEBUG = false\n        window.onerror = function (msg, src, line, col, err) {\n          try {\n            NP_DEBUG && console.error('SCRIPT ERROR:', msg, 'at', line + ':' + col)\n          } catch (e) {}\n        }\n        const REPORT = reportObject || window.report || window.DEV_REPORT || null\n        if (!REPORT) {\n          NP_DEBUG && console.warn('[NeuPrint] No report data found. Provide window.report or DEV JSON.')\n          return\n        }\n\n        /* =========================================================\n       Module 0) Data (REPORT)\n    ========================================================= */\n        /* =========================================================\n       Module 1) Utilities (keep minimal, shared)\n    ========================================================= */\n        // Utilities\n        function $(id) {\n          return document.getElementById(id)\n        }\n\n        function esc(v) {\n          return String(v ?? '').replace(/[&<>\"']/g, function (ch) {\n            return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;', \"'\": '&#39;' }[ch]\n          })\n        }\n\n        function setText(id, value) {\n          const el = $(id)\n          if (el) el.textContent = String(value)\n        }\n        function clamp01(x) {\n          const n = Number(x)\n          if (!Number.isFinite(n)) return 0\n          return Math.max(0, Math.min(1, n))\n        }\n        function pct01ToPctInt(x) {\n          return Math.round(clamp01(x) * 100)\n        }\n\n        function pctTripletFromMix(mix) {\n          // Use preserved percent ints when provided so the chart matches UI expectations exactly.\n          if (mix && mix._pct) {\n            const h = Math.max(0, Math.min(100, Number(mix._pct.human ?? 0)))\n            const y = Math.max(0, Math.min(100, Number(mix._pct.hybrid ?? 0)))\n            const a = Math.max(0, Math.min(100, Number(mix._pct.ai ?? 0)))\n            const s = h + y + a\n            if (s === 100) return [h, y, a]\n          }\n          // Otherwise, round and then adjust so the sum is exactly 100.\n          const raw = [clamp01(mix?.human ?? 0) * 100, clamp01(mix?.hybrid ?? 0) * 100, clamp01(mix?.ai ?? 0) * 100]\n          const base = raw.map((v) => Math.floor(v))\n          let rem = 100 - (base[0] + base[1] + base[2])\n          const frac = raw.map((v, i) => ({ i, f: v - base[i] })).sort((a, b) => b.f - a.f)\n          for (let k = 0; k < frac.length && rem > 0; k++) {\n            base[frac[k].i] += 1\n            rem -= 1\n          }\n          // Final safety\n          const s2 = base[0] + base[1] + base[2]\n          if (s2 !== 100) {\n            base[0] += 100 - s2\n          }\n          return base\n        }\n                function formatPct01(x) {\n          return pct01ToPctInt(x) + '%'\n        }\n        function fmt2(x) {\n          const n = Number(x)\n          if (!Number.isFinite(n)) return '0.00'\n          return n.toFixed(2)\n        }\n\n        // =========================================================\n        // mix_ratio fallback (Reasoning Control Distribution)\n        // - Primary: r.ai.mix_ratio (0-1)\n        // - Fallback: r.agency.distribution.*_pct (0-100)\n        // =========================================================\n        function getMixFromReport(r) {\n          // Returns 0..1 ratios.\n          // Accepts 0..1, 0..100, or strings like \"82%\".\n          // Also preserves percent-int inputs (82) so the UI can match them exactly.\n\n          function parse01(v) {\n            if (v == null) return null\n            if (typeof v === 'string') {\n              const s = v.trim().replace('%', '')\n              if (!s) return null\n              const n = Number(s)\n              if (!Number.isFinite(n)) return null\n              return clamp01(n > 1 ? n / 100 : n)\n            }\n            const n = Number(v)\n            if (!Number.isFinite(n)) return null\n            return clamp01(n > 1 ? n / 100 : n)\n          }\n\n          function normTriplet(h, y, a) {\n            const hh = clamp01(h)\n            const yy = clamp01(y)\n            const aa = clamp01(a)\n            const s = hh + yy + aa\n            if (s <= 0) return { human: 0, hybrid: 0, ai: 0 }\n            return { human: hh / s, hybrid: yy / s, ai: aa / s }\n          }\n\n          try {\n            // 1) Prefer explicit distribution percent ints (UI-facing) when available.\n            const d = r && r.agency && r.agency.distribution ? r.agency.distribution : null\n            if (d && (d.human_pct != null || d.hybrid_pct != null || d.ai_pct != null)) {\n              // If only Hybrid/AI are provided (common in some backends), derive Human as the residual.\n              // This prevents accidental pickup of unrelated confidence fields.\n              const yp0 = d.hybrid_pct == null ? null : Number(d.hybrid_pct)\n              const ap0 = d.ai_pct == null ? null : Number(d.ai_pct)\n              let hp0 = d.human_pct == null ? null : Number(d.human_pct)\n\n              const yp = Math.max(0, Math.min(100, Number.isFinite(yp0) ? yp0 : 0))\n              const ap = Math.max(0, Math.min(100, Number.isFinite(ap0) ? ap0 : 0))\n              if (hp0 == null && (d.hybrid_pct != null || d.ai_pct != null)) {\n                hp0 = 100 - yp - ap\n              }\n              const hp = Math.max(0, Math.min(100, Number.isFinite(hp0) ? hp0 : 0))\n              const out = normTriplet(hp / 100, yp / 100, ap / 100)\n              out._pct = { human: Math.round(hp), hybrid: Math.round(yp), ai: Math.round(ap) }\n              return out\n            }\n\n            // 2) mix_ratio object (0..1 or 0..100)\n            const mix = r && r.ai && r.ai.mix_ratio ? r.ai.mix_ratio : null\n            if (mix && (mix.human != null || mix.hybrid != null || mix.ai != null)) {\n              const y = parse01(mix.hybrid ?? 0) ?? 0\n              const a = parse01(mix.ai ?? 0) ?? 0\n              let h = parse01(mix.human)\n\n              // If Human is missing, derive it as residual.\n              if (h == null && (mix.hybrid != null || mix.ai != null)) {\n                h = clamp01(1 - y - a)\n              }\n\n              // If the three don't look like a valid triplet (e.g., Human accidentally stored as confidence),\n              // prefer residual so Hybrid/AI remain exact.\n              if (h != null && y + a > 0) {\n                const s = h + y + a\n                if (s > 1.001) {\n                  h = clamp01(1 - y - a)\n                }\n              }\n              return normTriplet(h ?? 0, y, a)\n            }\n\n            // 3) Alternative schema support (optional)\n            const alt = r && r.reasoning_control && r.reasoning_control.distribution ? r.reasoning_control.distribution : null\n            if (alt && (alt.human != null || alt.hybrid != null || alt.ai != null)) {\n              const h = parse01(alt.human ?? 0) ?? 0\n              const y = parse01(alt.hybrid ?? 0) ?? 0\n              const a = parse01(alt.ai ?? 0) ?? 0\n              return normTriplet(h, y, a)\n            }\n\n            return { human: 0, hybrid: 0, ai: 0 }\n          } catch (e) {\n            return { human: 0, hybrid: 0, ai: 0 }\n          }\n        }\n\n        function getConfidenceIndex01(r) {\n          // Goal: display the same confidence users see in the hero chips (e.g., 88%),\n          // while remaining compatible with multiple backend schemas.\n\n          function parse01(v) {\n            if (v == null) return null\n            if (typeof v === 'string') {\n              const s = v.trim().replace('%', '')\n              if (s === '') return null\n              const n = Number(s)\n              if (!isFinite(n)) return null\n              return clamp01(n > 1 ? n / 100 : n)\n            }\n            const n = Number(v)\n            if (!isFinite(n)) return null\n            return clamp01(n > 1 ? n / 100 : n)\n          }\n\n          // 1) Most explicit / most user-facing fields first (accept 0..1, 0..100, or \"88%\").\n          const candidates = [\n            r?.hero?.chips?.confidence_index,\n            r?.hero?.chips?.confidence,\n            r?.hero?.chips?.confidence_pct,\n            r?.hero?.confidence_index,\n            r?.hero?.confidence,\n            r?.hero?.confidence_pct,\n            r?.classification_confidence,\n            r?.confidence_index,\n            r?.confidence,\n            r?.forensic?.confidence,\n            r?.forensic?.confidence_index,\n            r?.determination?.confidence,\n            r?.determination?.confidence_index,\n            r?.ai?.confidence_index,\n          ]\n\n          for (const v of candidates) {\n            const out = parse01(v)\n            if (out != null) return out\n          }\n\n          // 2) If nothing else exists, fall back to CFF type confidences.\n          const cff1 = parse01(r?.cff?.final_determination?.type_confidence)\n          if (cff1 != null) return cff1\n          const cff2 = parse01(r?.cff?.observed_patterns?.type_confidence)\n          if (cff2 != null) return cff2\n\n          return 0\n        }\n\n\n\n        function riskBandFromReliability(band) {\n          if (band === 'HIGH')\n            return { label: 'Low', note: 'High reliability band, low false-positive risk.' }\n          if (band === 'MEDIUM')\n            return { label: 'Medium', note: 'Medium reliability band, review recommended.' }\n          if (band === 'LOW')\n            return { label: 'High', note: 'Low reliability band, do not use alone.' }\n          return { label: 'Unknown', note: 'Reliability band unavailable.' }\n        }\n\n        const report = REPORT\n\n\n        /* =========================================================\n       Theme tokens to JS (from CSS)\n    ========================================================= */\n        const css = getComputedStyle(document.documentElement)\n        const THEME = {\n          text: css.getPropertyValue('--text').trim(),\n          accentA: css.getPropertyValue('--accentA').trim(),\n          accentB: css.getPropertyValue('--accentB').trim(),\n          accentC: css.getPropertyValue('--accentC').trim(),\n          accentD: css.getPropertyValue('--accentD').trim(),\n          accentE: css.getPropertyValue('--accentE').trim(),\n          pillB: css.getPropertyValue('--pillB').trim(),\n          pillD: css.getPropertyValue('--pillD').trim(),\n          pillN: css.getPropertyValue('--pillN').trim(),\n        }\n\n        const CHART_ANIM_MS = parseInt(css.getPropertyValue('--chartAnimDuration'), 10) || 1400\n        const CHART_DELAY_MS = parseInt(css.getPropertyValue('--chartAnimDelay'), 10) || 180\n\n        if (window.Chart) {\n          Chart.defaults.font.family =\n            '\"Barlow\", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif'\n          Chart.defaults.font.size = 11\n          Chart.defaults.color = THEME.text || '#0f172a'\n        }\n\n        /* =========================================================\n       Plugin helpers (white background label boxes)\n    ========================================================= */\n        function roundRectPath(ctx, x, y, w, h, r) {\n          const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2))\n          ctx.beginPath()\n          ctx.moveTo(x + rr, y)\n          ctx.arcTo(x + w, y, x + w, y + h, rr)\n          ctx.arcTo(x + w, y + h, x, y + h, rr)\n          ctx.arcTo(x, y + h, x, y, rr)\n          ctx.arcTo(x, y, x + w, y, rr)\n          ctx.closePath()\n        }\n\n        function drawLabelBox(ctx, x, y, text, opt) {\n          const padX = opt && opt.padX != null ? opt.padX : 6\n          const padY = opt && opt.padY != null ? opt.padY : 3\n          const radius = opt && opt.radius != null ? opt.radius : 6\n          const font = opt && opt.font ? opt.font : '500 11px Barlow, system-ui, sans-serif'\n          const textColor = opt && opt.textColor ? opt.textColor : '#0f172a'\n          const bg = opt && opt.bg ? opt.bg : '#ffffff'\n          const stroke = opt && opt.stroke ? opt.stroke : 'rgba(226,232,240,.95)'\n          const centerX = !!(opt && opt.centerX)\n\n          ctx.save()\n          ctx.font = font\n          ctx.textBaseline = 'middle'\n\n          const m = ctx.measureText(text)\n          const w = Math.ceil(m.width + padX * 2)\n          const h = Math.ceil(12 + padY * 2)\n\n          const rx = centerX ? Math.round(x - w / 2) : x\n\n          roundRectPath(ctx, rx, y, w, h, radius)\n          ctx.fillStyle = bg\n          ctx.fill()\n          ctx.strokeStyle = getComputedStyle(document.documentElement)\n            .getPropertyValue('--_sigToneC')\n            .trim()\n          ctx.lineWidth = 1\n          /* ctx.stroke(); */\n\n          ctx.fillStyle = textColor\n          ctx.fillText(text, rx + padX, y + h / 2)\n\n          ctx.restore()\n          return { w, h }\n        }\n\n        function drawLabelDot(ctx, cx, cy, text, opt) {\n          const font = opt && opt.font ? opt.font : '600 10px Barlow, system-ui, sans-serif'\n          const textColor = opt && opt.textColor ? opt.textColor : '#0f172a'\n          const bg = opt && opt.bg ? opt.bg : '#ffffff'\n          const stroke = opt && opt.stroke ? opt.stroke : 'rgba(226,232,240,.95)'\n          const minR = opt && opt.minR != null ? opt.minR : 12\n          const pad = opt && opt.pad != null ? opt.pad : 6\n\n          ctx.save()\n          ctx.font = font\n          ctx.textAlign = 'center'\n          ctx.textBaseline = 'middle'\n\n          const m = ctx.measureText(text)\n          const r = max2(minR, intceil(m.width / 2) + pad)\n\n          ctx.beginPath()\n          ctx.arc(cx, cy, r, 0, Math.PI * 2)\n          ctx.closePath()\n          ctx.fillStyle = bg\n          ctx.fill()\n\n          const tok = getComputedStyle(document.documentElement)\n            .getPropertyValue('--_sigToneC')\n            .trim()\n          ctx.strokeStyle = tok || stroke\n          ctx.lineWidth = 1\n          ctx.stroke()\n\n          ctx.fillStyle = textColor\n          ctx.fillText(text, cx, cy + 0.5)\n\n          ctx.restore()\n          return r\n        }\n\n        function max2(a, b) {\n          return a > b ? a : b\n        }\n        function intceil(x) {\n          return Math.ceil(x)\n        }\n\n        /* =========================================================\n       2-1) Donut center text plugin\n    ========================================================= */\n        const centerTextPlugin = {\n          id: 'centerTextPlugin',\n          afterDraw(chart) {\n            const opts =\n              (chart.options && chart.options.plugins && chart.options.plugins.centerText) || null\n            if (!opts) return\n\n            const ctx = chart.ctx\n            const meta = chart.getDatasetMeta(0)\n            if (!meta || !meta.data || !meta.data.length) return\n\n            const arc = meta.data[0]\n            const x = arc.x\n            const y = arc.y\n\n            const top = String(opts.top || '')\n            const bottom = String(opts.bottom || '')\n            const yOffset = Number(opts.yOffset || 0)\n\n            const topFont = opts.topFont || '500 14px Barlow, system-ui, sans-serif'\n            const bottomFont = opts.bottomFont || '500 14px Barlow, system-ui, sans-serif'\n\n            ctx.save()\n            ctx.textAlign = 'center'\n            ctx.textBaseline = 'middle'\n\n            ctx.fillStyle = THEME.text || '#0f172a'\n            ctx.font = topFont\n            ctx.fillText(top, x, y - 8 + yOffset)\n\n            ctx.font = bottomFont\n            ctx.fillText(bottom, x, y + 12 + yOffset)\n\n            ctx.restore()\n          },\n        }\n\n        /* =========================================================\n       2-2) Bar value labels\n    ========================================================= */\n        const barValueLabelsPlugin = {\n          id: 'barValueLabelsPlugin',\n          afterDatasetsDraw(chart) {\n            const opts =\n              (chart.options && chart.options.plugins && chart.options.plugins.barValueLabels) ||\n              null\n            if (!opts) return\n\n            const ctx = chart.ctx\n            const indexAxis = (chart.options && chart.options.indexAxis) || 'x'\n            const fmt = opts.format || 'float2'\n            const color = opts.textColor || THEME.text || '#0f172a'\n\n            const dsIndex = opts.datasetIndex != null ? opts.datasetIndex : 0\n            const meta = chart.getDatasetMeta(dsIndex)\n            if (!meta || meta.hidden) return\n\n            const data = chart.data.datasets[dsIndex].data || []\n            ctx.save()\n\n            for (let i = 0; i < meta.data.length; i++) {\n              const el = meta.data[i]\n              const v = data[i]\n              if (v == null) continue\n\n              let text = ''\n              if (fmt === 'pct') {\n                text = Math.round(Number(v)) + '%'\n              } else if (fmt === 'float1') {\n                text = Number(v).toFixed(1)\n              } else if (fmt === 'float2') {\n                text = Number(v).toFixed(2)\n              } else {\n                text = String(v)\n              }\n\n              if (indexAxis === 'y') {\n                const x = el.x + 8\n                const y = el.y - 10\n                drawLabelBox(ctx, x, y, text, {\n                  textColor: color,\n                  bg: '#fff',\n                  stroke: 'rgba(226,232,240,.95)',\n                  radius: 6,\n                })\n              } else {\n                const x = el.x\n                const y = el.y - 24\n                drawLabelBox(ctx, x, y, text, {\n                  textColor: color,\n                  bg: '#fff',\n                  stroke: 'rgba(226,232,240,.95)',\n                  radius: 6,\n                  centerX: true,\n                })\n              }\n            }\n\n            ctx.restore()\n          },\n        }\n\n        /* =========================================================\n       2-3) Radar value labels\n    ========================================================= */\n        const radarValueLabelsPlugin = {\n          id: 'radarValueLabelsPlugin',\n          afterDatasetsDraw(chart) {\n            const opts =\n              (chart.options && chart.options.plugins && chart.options.plugins.radarValueLabels) ||\n              null\n            if (!opts) return\n\n            const dsIndex = opts.datasetIndex != null ? opts.datasetIndex : 0\n            const meta = chart.getDatasetMeta(dsIndex)\n            if (!meta || meta.hidden) return\n\n            const scale = chart.scales && chart.scales.r\n            if (!scale) return\n\n            const labels = chart.data.labels || []\n            const values = chart.data.datasets[dsIndex].data || []\n\n            const ctx = chart.ctx\n            ctx.save()\n            ctx.font = '500 10px Barlow, system-ui, sans-serif'\n            ctx.textAlign = 'center'\n            ctx.textBaseline = 'middle'\n\n            const maxV = typeof scale.max === 'number' ? scale.max : 1\n\n            const outV = maxV * Number(opts.outFactor || 1.15)\n            const extraPx = Number(opts.extraPx || 10)\n\n            for (let i = 0; i < labels.length; i++) {\n              const v = Number(values[i] ?? 0)\n              const txt = fmt2(v)\n\n              const pt = scale.getPointPositionForValue(i, outV)\n\n              const cx = scale.xCenter\n              const cy = scale.yCenter\n              const dx = pt.x - cx\n              const dy = pt.y - cy\n              const len = Math.hypot(dx, dy) || 1\n              const ox = pt.x + (dx / len) * extraPx\n              const oy = pt.y + (dy / len) * extraPx\n\n              drawLabelDot(ctx, ox, oy - 2, txt, {\n                font: '600 10px Barlow, system-ui, sans-serif',\n                textColor: THEME.text || '#0f172a',\n                bg: '#fff',\n                stroke: 'rgba(226,232,240,.95)',\n                minR: 12,\n                pad: 6,\n              })\n            }\n\n            ctx.restore()\n          },\n        }\n\n        /* =========================================================\n       2-4) Pulsing ring animation for Structural Position Map\n    ========================================================= */\n\n        /* Color helpers for pulse rings (supports hex/rgb/rgba) */\n        function _parseColorToRgb(color) {\n          if (!color) return null\n          const c = String(color).trim()\n          let m = c.match(/^rgba?\\(([^)]+)\\)$/i)\n          if (m) {\n            const parts = m[1].split(',').map((s) => s.trim())\n            const r = parseFloat(parts[0])\n            const g = parseFloat(parts[1])\n            const b = parseFloat(parts[2])\n            if ([r, g, b].every(Number.isFinite)) return { r, g, b }\n          }\n          m = c.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i)\n          if (m) {\n            let hex = m[1]\n            if (hex.length === 3) {\n              hex = hex\n                .split('')\n                .map((ch) => ch + ch)\n                .join('')\n            }\n            const n = parseInt(hex, 16)\n            const r = (n >> 16) & 255\n            const g = (n >> 8) & 255\n            const b = n & 255\n            return { r, g, b }\n          }\n          return null\n        }\n\n        function _rgba(color, alpha, fallbackRgb) {\n          const a = Math.max(0, Math.min(1, Number(alpha)))\n          const fb =\n            fallbackRgb && String(fallbackRgb).trim() ? String(fallbackRgb).trim() : '249,123,23'\n          const rgb = _parseColorToRgb(color)\n          if (rgb) {\n            return (\n              'rgba(' +\n              Math.round(rgb.r) +\n              ',' +\n              Math.round(rgb.g) +\n              ',' +\n              Math.round(rgb.b) +\n              ',' +\n              a.toFixed(3) +\n              ')'\n            )\n          }\n          return 'rgba(' + fb + ',' + a.toFixed(3) + ')'\n        }\n        const pulseCurrentPointPlugin = {\n          id: 'pulseCurrentPointPlugin',\n          afterDatasetsDraw(chart) {\n            const opts =\n              (chart.options && chart.options.plugins && chart.options.plugins.pulseCurrentPoint) ||\n              null\n            if (!opts) return\n\n            const dsIndex = opts.datasetIndex != null ? opts.datasetIndex : 3\n            const meta = chart.getDatasetMeta(dsIndex)\n            if (!meta || meta.hidden || !meta.data || !meta.data.length) return\n\n            const point = meta.data[0]\n            if (!point) return\n\n            const pr = point.getProps ? point.getProps(['radius', 'x', 'y'], false) : null\n\n            const px = pr && Number.isFinite(pr.x) ? pr.x : point.x\n            const py = pr && Number.isFinite(pr.y) ? pr.y : point.y\n            const curRadius =\n              pr && Number.isFinite(pr.radius) ? pr.radius : (point.options?.radius ?? 0)\n\n            if (curRadius < 0.5) {\n              return\n            }\n\n            const ctx = chart.ctx\n            const now = performance.now()\n\n            if (!chart.$pulse) {\n              chart.$pulse = { start: now, raf: null, started: false }\n            }\n\n            const startDelayMs = Number(opts.startDelayMs || 0)\n\n            if (!chart.$pulse.startedAt) {\n              chart.$pulse.startedAt = now\n              chart.$pulse.start = now\n              chart.$pulse.started = false\n            }\n\n            if (!chart.$pulse.started) {\n              if (now - chart.$pulse.startedAt < startDelayMs) {\n                return\n              }\n              chart.$pulse.started = true\n              chart.$pulse.start = now\n            }\n\n            const delayMs = Number(opts.delayMs ?? 0)\n            const fadeInMs = Number(opts.fadeInMs ?? 450)\n            const period = Number(opts.periodMs || 1200)\n\n            const elapsed = now - chart.$pulse.start\n            if (elapsed < delayMs) return\n\n            const t2 = elapsed - delayMs\n            const base = (t2 % period) / period\n\n            const rings = Number(opts.rings ?? 4)\n            const baseR = 0\n            const maxR = Math.max(Number(opts.maxR || 52), curRadius + 18)\n\n            const smoothAlpha = (p) => Math.sin(Math.PI * p)\n            const smoothGrow = (p) => 1 - Math.cos((Math.PI / 2) * p)\n\n            const globalFade = Math.max(0, Math.min(1, t2 / fadeInMs))\n\n            for (let j = 0; j < rings; j++) {\n              const phase = (base + j / rings) % 1\n\n              const r = baseR + (maxR - baseR) * smoothGrow(phase)\n              const aMax = Number(opts.maxAlpha ?? 0.22)\n              const a = aMax * smoothAlpha(phase) * globalFade\n\n              if (a < 0.003) continue\n\n              ctx.save()\n              ctx.beginPath()\n              ctx.arc(px, py, r, 0, Math.PI * 2)\n              ctx.strokeStyle = _rgba(opts.color || THEME.accentE || '#f59e0b', a, '249,123,23')\n              ctx.lineWidth = 2\n              ctx.stroke()\n              ctx.restore()\n            }\n\n            if (!chart.$pulse.raf) {\n              const tick = () => {\n                if (chart && chart.ctx) {\n                  try {\n                    chart.draw()\n                  } catch (_e) {}\n                }\n                chart.$pulse.raf = requestAnimationFrame(tick)\n              }\n              chart.$pulse.raf = requestAnimationFrame(tick)\n            }\n          },\n          beforeDestroy(chart) {\n            if (chart && chart.$pulse && chart.$pulse.raf) {\n              cancelAnimationFrame(chart.$pulse.raf)\n              chart.$pulse.raf = null\n            }\n          },\n        }\n\n        /* =========================================================\n   plugin: stacked horizontal bar inner labels (robust)\n   - \ucd5c\ub300 \uad6c\uac04: \"Label 88%\"\n   - \ub098\uba38\uc9c0: \"\"\n   - \uae00\uc790: 14px, \ud770\uc0c9\n   - (\ud575\uc2ec) onComplete \ub204\ub77d/\ub36e\uc5b4\uc4f0\uae30\uc5d0\ub3c4 \ub77c\ubca8\uc774 \ubc18\ub4dc\uc2dc \ub728\ub3c4\ub85d,\n            chart.$labelsReady \ub610\ub294 chart.animating === false \uc5d0\uc11c \ucd9c\ub825\n========================================================= */\n        const STACKBAR_LABELS_AFTER_ANIM = {\n          id: 'stackBarLabelsAfterAnim',\n          afterDatasetsDraw(chart, args, pluginOptions) {\n            if (!chart) return\n\n            const isDone = chart.$labelsReady === true || chart.animating === false\n            if (!isDone) return\n\n            const ctx = chart.ctx\n            const ds = chart.data && chart.data.datasets ? chart.data.datasets : []\n            if (!ds.length) return\n\n            const values = ds.map((d) => Number((d.data && d.data[0]) ?? 0))\n            const maxVal = Math.max(...values)\n            const maxIdx = values.indexOf(maxVal)\n\n            const font =\n              pluginOptions && pluginOptions.font\n                ? pluginOptions.font\n                : '700 14px Barlow, system-ui, sans-serif'\n            const color = pluginOptions && pluginOptions.color ? pluginOptions.color : '#ffffff'\n\n            ctx.save()\n            ctx.font = font\n            ctx.fillStyle = color\n            ctx.textAlign = 'center'\n            ctx.textBaseline = 'middle'\n\n            for (let i = 0; i < ds.length; i++) {\n              const meta = chart.getDatasetMeta(i)\n              const el = meta && meta.data ? meta.data[0] : null\n              if (!el) continue\n\n              const v = values[i]\n              if (!Number.isFinite(v) || v <= 0) continue\n\n              const x1 = Number(el.base)\n              const x2 = Number(el.x)\n              const y = Number(el.y)\n\n              if (!Number.isFinite(x1) || !Number.isFinite(x2) || !Number.isFinite(y)) continue\n\n              const xCenter = (x1 + x2) / 2\n\n              const name = ds[i].label || ''\n              const text = i === maxIdx ? (name ? name + ' ' + v + '%' : v + '%') : v + '%'\n\n              ctx.fillText(text, xCenter, y)\n            }\n\n            ctx.restore()\n          },\n        }\n\n        /* =========================================================\n       Register plugins\n       (\uc218\uc815) Chart \uc874\uc7ac\ud560 \ub54c\ub9cc register \ud558\ub3c4\ub85d \uace0\uc815\n    ========================================================= */\n        if (window.Chart) {\n          Chart.register(\n            centerTextPlugin,\n            barValueLabelsPlugin,\n            radarValueLabelsPlugin,\n            pulseCurrentPointPlugin,\n            STACKBAR_LABELS_AFTER_ANIM,\n          )\n        }\n\n        /* =========================================================\n       Render: DOM binding\n    ========================================================= */\n\n        function renderReport(r) {\n          renderHero(r)\n          renderHeaderPills(r)\n          renderExecutiveMetrics(r)\n          renderSummaryPanels(r)\n          renderAuthorshipPanels(r)\n          renderCffPanels(r)\n          renderCffTable(r)\n          renderArcPanels(r)\n          renderArcTable(r)\n          renderMapPanels(r)\n          renderStabilityPanels(r)\n          renderIdentityPanels(r)\n          renderAgencySignals(r)\n          renderRoleFit(r)\n          renderMetadata(r)\n        }\n\n        function renderHero(r) {\n          const meta = r.meta || {}\n          const hero = r.hero || {}\n\n          setText('heroTitle', hero.title || '')\n          setText('heroDesc', hero.description || '')\n\n          setText('verifyUrlText', meta.verify_url || meta.verifyUrl || '')\n          setText(\n            'verifyIdText',\n            meta.verification_id || meta.assessment_id || r.assessment_id || '',\n          )\n\n          setText(\n            'heroDecisionQuote',\n            hero.decision_compression_quote ||\n              hero.decision_quote ||\n              hero.decisionQuote ||\n              'Demonstrates exploratory reasoning that converts observation into cross-domain conceptual inquiry, but prioritizes ideational expansion over evaluative convergence, indicating the need to reinforce counterfactual testing and disciplined conclusion consolidation.',\n          )\n\n          setText(\n            'rslOneLine',\n            r.rsl?.summary?.one_line || r.rsl?.summary_one_line || r.rsl?.one_liner || '',\n          )\n          setText(\n            'rslSummaryText',\n            r.rsl?.summary?.paragraph || r.rsl?.summary_paragraph || r.rsl?.summary_text || '',\n          )\n\n          const qr = $('qrImg')\n          if (qr) {\n            if (meta.qr_src) qr.src = meta.qr_src\n            qr.alt = meta.qr_alt || 'QR'\n          }\n        }\n\n        function setPill(id, value, toneClass) {\n          const el = $(id)\n          if (!el) return\n          if (el.dataset && el.dataset.static === 'true') return\n          el.textContent = String(value)\n          el.className = 'pill ' + (toneClass || 'toneN')\n        }\n\n        function bestTrackName(trackScores) {\n          if (!trackScores || typeof trackScores !== 'object') return ''\n          let bestName = ''\n          let bestVal = -1\n          for (const [k, v] of Object.entries(trackScores)) {\n            const n = Number(v)\n            if (Number.isFinite(n) && n > bestVal) {\n              bestVal = n\n              bestName = k\n            }\n          }\n          return bestName\n        }\n\n        function renderHeaderPills(r) {\n          const chips = r.hero && r.hero.chips ? r.hero.chips : {}\n\n          const fri = chips.fri != null ? Number(chips.fri) : Number(r?.rsl?.fri ?? 0)\n          const rslLevel = chips.rsl_level || r?.rsl?.overall_level_display || ''\n          const det =\n            chips.determination ||\n            r.ai?.final_determination_label ||\n            r.cff?.final_determination_label ||\n            r.ai?.final_classification ||\n            ''\n          const control =\n            chips.control ||\n            r.agency?.control_label ||\n            r.agency?.control ||\n            r.ai?.control_label ||\n            ''\n          const roleFit = chips.role_fit || bestTrackName(r.role_fit?.track_scores) || ''\n\n          setPill('reasoningIndexPill', fmt2(Math.max(0, Math.min(5, fri))), 'toneC')\n          setPill('rslPill', rslLevel || '-', 'toneB')\n          setPill('finalDetPill', det || '-', 'toneE')\n          setPill('controlPill', control || '-', 'toneN')\n          setPill('jobFitPill', roleFit || '-', 'toneD')\n        }\n\n        function renderExecutiveMetrics(r) {\n          const decision = r.ai?.final_classification || 'Unknown'\n          const confIdx = getConfidenceIndex01(r)\n\n          setText('mRslMean', fmt2(Number(r.rsl?.fri ?? 0)))\n          const p01 = Number(r.rsl?.percentile_0to1 ?? 0)\n          const top = Math.max(0, Math.min(100, Math.round((1 - p01) * 100)))\n\n          const rb = riskBandFromReliability(r.ai?.detection_reliability_band)\n        }\n\n        function renderSummaryPanels(r) {\n          const tags = $('topicTags')\n          if (tags) {\n            tags.innerHTML = ''\n            ;(r.topic_tags || []).forEach((t) => {\n              const s = document.createElement('span')\n              s.className = 'kpi'\n              s.textContent = t\n              tags.appendChild(s)\n            })\n          }\n        }\n\n        function renderAuthorshipPanels(r) {\n          const mapNote = r.reasoning_map?.note ? ' ' + r.reasoning_map.note : ''\n          setText('aiInterpretation', (r.ai?.interpretation || '') + '. ' + mapNote)\n          setText('aiPatternLabel', r.ai?.pattern_label || '')\n          setText('aiReliability', r.ai?.detection_reliability_band || '')\n\n          const mix = getMixFromReport(r)\n          const mixKpis = $('mixKpis')\n          if (mixKpis) {\n            mixKpis.innerHTML = ''\n            ;[\n              ['human', mix.human],\n              ['hybrid', mix.hybrid],\n              ['ai', mix.ai],\n            ].forEach(([k, v]) => {\n              const span = document.createElement('span')\n              span.className = 'kpi'\n              span.innerHTML = k + ': <span class=\"code\">' + formatPct01(v) + '</span>'\n              mixKpis.appendChild(span)\n            })\n          }\n        }\n\n        function renderCffPanels(r) {\n          const cff = r.cff || {}\n          const fd = cff.final_determination || {}\n          const op = cff.observed_patterns || {}\n\n          const finalLabel = fd.label || ''\n          const finalConf = fd.type_confidence == null ? '' : fmt2(fd.type_confidence)\n          setText('cffFinalLabel', finalLabel)\n          setText('cffFinalLabel2', finalLabel)\n          setText('cffFinalConf', finalConf)\n          setText('cffFinalConf2', finalConf)\n          setText('cffFinalMeaning', fd.explanation || fd.meaning || '')\n\n          const p1 = op.primary_pattern || op.primary || op.primary_label || ''\n          const p2 = op.secondary_pattern || op.secondary || op.secondary_label || ''\n          const opConf = op.type_confidence == null ? '' : fmt2(op.type_confidence)\n          setText('cffPrimary', p1)\n          setText('cffPrimary2', p1)\n          setText('cffSecondary', p2)\n          setText('cffSecondary2', p2)\n          setText('cffTypeConfidence', opConf)\n          setText('cffTypeConfidence2', opConf)\n          setText('cffPatternMeaning', op.explanation || op.meaning || '')\n\n          setText('signatureNote', cff.signature_fingerprint?.description || '')\n        }\n\n        function renderCffTable(r) {\n          const body = $('cffTableBody')\n          if (!body) return\n          body.innerHTML = ''\n\n          const names = {\n            AAS: 'Argument Architecture Style',\n            CTF: 'Cognitive Transition Flow',\n            RMD: 'Reasoning Momentum Delta',\n            RDX: 'Revision Depth Index',\n            EDS: 'Evidence Diversity Score',\n            IFD: 'Intent Friction Delta',\n            'KPF-Sim': 'Keystroke Pattern Fingerprint Similarity',\n            'TPS-H': 'Thought Pattern Similarity (History-based)',\n          }\n\n          const order = ['AAS', 'CTF', 'RMD', 'RDX', 'EDS', 'IFD', 'KPF-Sim', 'TPS-H']\n          const ind = r.cff?.indicators || {}\n\n          function getVal(code) {\n            if (code === 'KPF-Sim') {\n              return (\n                ind['KPF-Sim'] ?? ind.KPF_SIM ?? ind.KPFSim ?? ind.kpf_sim ?? ind.kpfSim ?? null\n              )\n            }\n            if (code === 'TPS-H') {\n              return ind['TPS-H'] ?? ind.TPS_H ?? ind.TPSH ?? ind.tps_h ?? ind.tpsH ?? null\n            }\n            return ind[code] ?? null\n          }\n\n          function fmtScore(code, raw) {\n            if (raw == null) return 'N/A'\n            if (typeof raw === 'number') {\n              if (code === 'TPS-H' && raw > 1) return String(Math.round(raw))\n              return fmt2(raw)\n            }\n            return String(raw)\n          }\n\n          order.forEach((code) => {\n            const raw = getVal(code)\n            const isNA = raw == null\n\n            const tr = document.createElement('tr')\n\n            const tdCode = document.createElement('td')\n            tdCode.className = 'code'\n            tdCode.textContent = code\n\n            const tdName = document.createElement('td')\n            tdName.textContent = names[code] || code\n\n            const tdScore = document.createElement('td')\n            tdScore.textContent = fmtScore(code, raw)\n\n            const tdStatus = document.createElement('td')\n            tdStatus.textContent = isNA ? 'Excluded' : 'Active'\n\n            tr.appendChild(tdCode)\n            tr.appendChild(tdScore)\n            tr.appendChild(tdName)\n            tr.appendChild(tdStatus)\n            body.appendChild(tr)\n          })\n        }\n\n        function renderArcPanels(r) {\n          const levelText = (\n            (r.rsl?.overall_level || '?') +\n            ' ' +\n            (r.rsl?.overall_label || '')\n          ).trim()\n          const fri = Number(r.rsl?.fri ?? 0)\n          const rel = Number(r.rsl?.stability_index ?? 0)\n          const p01 = Number(r.rsl?.percentile_0to1 ?? 0)\n          const top = Math.max(0, Math.min(100, Math.round(100 - p01 * 100)))\n\n          setText('mRslLevel', r.rsl?.overall_level_display || levelText)\n          setText('mRslLevelNote', String(r.rsl?.overall_level_note || '').trim())\n          setText('mRslMean', fmt2(fri))\n          setText('mRslMeanNote', String(r.rsl?.fri_note || '').trim())\n          setText('mRslCohort', 'Top ' + String(top) + '%')\n          setText('mRslCohortNote', String(r.rsl?.cohort_note || '').trim())\n          setText('mRslStability', fmt2(rel))\n          setText('mRslStabilityNote', String(r.rsl?.stability_note || '').trim())\n\n          const arcKpis = $('arcKpis')\n          if (arcKpis) {\n            arcKpis.innerHTML = ''\n\n            const k1 = document.createElement('span')\n            k1.className = 'kpi kpiLabel'\n            k1.innerHTML = `Level: <span class=\"code\">${esc(r.rsl?.overall_level || '?')}</span>`\n\n            const k2 = document.createElement('span')\n            k2.className = 'kpi kpiLabel'\n            k2.innerHTML = `FRI: <span class=\"code\">${esc(fri.toFixed(2))}</span>`\n\n            const k3 = document.createElement('span')\n            k3.className = 'kpi kpiLabel'\n            k3.innerHTML = `Reliability: <span class=\"code\">${esc(fmt2(rel))}</span>`\n\n            const k4 = document.createElement('span')\n            k4.className = 'kpi kpiLabel'\n            k4.innerHTML = `Cohort: <span class=\"code\">Top ${esc(String(top))}%</span>`\n\n            arcKpis.appendChild(k1)\n            arcKpis.appendChild(k2)\n            arcKpis.appendChild(k3)\n            arcKpis.appendChild(k4)\n          }\n        }\n        function renderArcTable(r) {\n          const body = $('rslResultsByDimension') || $('arcTableBody')\n          if (!body) return\n          body.innerHTML = ''\n\n          const rows = Array.isArray(r.rsl?.dimensions) ? r.rsl.dimensions : []\n          rows.forEach((d) => {\n            const tr = document.createElement('tr')\n            const code = d.code ?? ''\n            const name = d.name ?? ''\n            const score = d.score == null ? '' : String(d.score)\n            const obs = d.observation ?? d.comment ?? ''\n\n            tr.innerHTML =\n              '<td><span class=\"code\">' +\n              esc(code) +\n              '</span> ' +\n              esc(name) +\n              '</td>' +\n              '<td>' +\n              esc(score) +\n              '</td>' +\n              '<td>' +\n              esc(obs) +\n              '</td>'\n\n            body.appendChild(tr)\n          })\n\n          __np_setArcTableLayout()\n        }\n\n        function renderMapPanels(r) {\n          const rm = r.reasoning_map || {}\n          const mapKpis = $('mapKpis')\n          if (mapKpis) {\n            mapKpis.innerHTML = ''\n\n            const sd = document.createElement('span')\n            sd.className = 'kpi'\n            sd.innerHTML =\n              'distance_to_human_center: <span class=\"code\">' +\n              Number(rm.distance_to_human_center_sd ?? 0).toFixed(2) +\n              ' SD</span>'\n\n            const pt = document.createElement('span')\n            pt.className = 'kpi'\n            const cx = Number(rm.current?.x ?? 0).toFixed(2)\n            const cy = Number(rm.current?.y ?? 0).toFixed(2)\n            pt.innerHTML = 'current_point: <span class=\"code\">(' + cx + ', ' + cy + ')</span>'\n\n            mapKpis.appendChild(sd)\n            mapKpis.appendChild(pt)\n          }\n        }\n\n        function renderStabilityPanels(r) {\n          setText(\n            r.stability?.history_status === 'None'\n              ? 'None'\n              : fmt2(r.stability?.type_consistency ?? 0),\n          )\n        }\n\n        function renderIdentityPanels(r) {}\n\n        function renderRoleFit(r) {\n          const rf = r.role_fit || {}\n\n          setText('hrProfile1', rf.cognitive_style_summary || '')\n\n          const hrKpis = $('hrKpis')\n          if (hrKpis) {\n            hrKpis.innerHTML = ''\n            ;(rf.track_scores || []).forEach((t) => {\n              const span = document.createElement('span')\n              span.className = 'kpi'\n              const pct = typeof t.pct === 'number' ? t.pct + '%' : t.pct || '-'\n              span.innerHTML =\n                '<span class=\"kpiLabel\">' +\n                esc(t.track || '') +\n                '</span>: <span class=\"code\">' +\n                esc(pct) +\n                '</span>'\n              hrKpis.appendChild(span)\n            })\n          }\n\n          setText('hrProfile2', rf.profile_statement || '')\n\n          const el3 = $('hrProfile3')\n          if (el3) {\n            const blocks = (rf.job_role_fit || [])\n              .map((grp) => {\n                const label = grp.track || ''\n                const roles = Array.isArray(grp.roles) ? grp.roles.join(', ') : ''\n                return '<span class=\"kpiLabel\">' + esc(label) + '</span> : ' + esc(roles)\n              })\n              .join('<br><br>')\n            el3.innerHTML = blocks\n          }\n\n          // Role Fit Inference Flow: closing statement\n          setText('rfClosing', rf.inference_flow?.closing || '')\n        }\n\n        \n    \n    function renderAgencySignals(r) {\n      const ul = document.getElementById('agencySignalsList')\n      const noteEl = document.getElementById('agencySignalsNote')\n      if (!ul) return\n      ul.innerHTML = ''\n\n      const raw = r && r.agency ? r.agency.observed_structural_signals : null\n      let arr = []\n      if (Array.isArray(raw)) arr = raw\n      else if (raw && Array.isArray(raw.bullets)) arr = raw.bullets\n\n      if (noteEl && raw && typeof raw.note === 'string' && raw.note.trim()) {\n        noteEl.textContent = raw.note.trim()\n      }\n\n      const fallback = [\n        'Revision activity occurs at semantic decision boundaries.',\n        'Argument order adjustments correspond to logical correction.',\n        'Consistency checks appear across structural transitions.',\n        'No sustained automated propagation is detected at reasoning boundaries.',\n      ]\n      const items = arr.length ? arr : fallback\n      items.forEach((s) => {\n        const li = document.createElement('li')\n        li.textContent = String(s)\n        ul.appendChild(li)\n      })\n    }\n\n\nfunction renderMetadata(r) {\n          const raw = $('rawJson')\n          if (raw) raw.textContent = JSON.stringify(r, null, 2)\n        }\n\n        /* =========================================================\n       Cognitive Fingerprint (canvas)\n    ========================================================= */\n        const SIGNATURE_KEYS = ['AAS', 'CTF', 'RMD', 'RDX', 'EDS', 'IFD']\n        const SIGNATURE_OPTS = {\n          resampleStepPx: 2.5,\n          preChaikin: true,\n          padPx: 14,\n          overscan: 0.96,\n          strokeRGBA: 'rgba(12,12,12,0.86)',\n          strokeWidth: 1.2,\n          animMs: parseInt(css.getPropertyValue('--sigAnimMs'), 10) || 1900,\n          colorCycle: false,\n          colorCycleMs: 2600,\n        }\n\n        function hashStr(s) {\n          let h = 2166136261\n          for (let i = 0; i < s.length; i++) {\n            h ^= s.charCodeAt(i)\n            h = Math.imul(h, 16777619)\n          }\n          return h >>> 0\n        }\n\n        function mulberry32(a) {\n          return function () {\n            let t = (a += 0x6d2b79f5)\n            t = Math.imul(t ^ (t >>> 15), t | 1)\n            t ^= t + Math.imul(t ^ (t >>> 7), t | 61)\n            return ((t ^ (t >>> 14)) >>> 0) / 4294967296\n          }\n        }\n\n        function setupHiDPICanvas(canvas) {\n          const dpr = window.devicePixelRatio || 1\n          const rect = canvas.getBoundingClientRect()\n          const w = Math.max(1, Math.floor(rect.width))\n          const h = Math.max(1, Math.floor(rect.height))\n          canvas.width = Math.floor(w * dpr)\n          canvas.height = Math.floor(h * dpr)\n          const ctx = canvas.getContext('2d')\n          ctx.setTransform(dpr, 0, 0, dpr, 0, 0)\n          return { ctx, width: w, height: h }\n        }\n\n        function bboxOfPoints(pts) {\n          let minX = Infinity,\n            minY = Infinity,\n            maxX = -Infinity,\n            maxY = -Infinity\n          for (const p of pts) {\n            if (p.x < minX) minX = p.x\n            if (p.y < minY) minY = p.y\n            if (p.x > maxX) maxX = p.x\n            if (p.y > maxY) maxY = p.y\n          }\n          if (!isFinite(minX)) return { minX: 0, minY: 0, maxX: 1, maxY: 1, w: 1, h: 1 }\n          const w = Math.max(1, maxX - minX)\n          const h = Math.max(1, maxY - minY)\n          return { minX, minY, maxX, maxY, w, h }\n        }\n\n        function fitRectToCanvas(bbox, canvasW, canvasH, pad, overscan) {\n          const innerW = Math.max(1, canvasW - pad * 2)\n          const innerH = Math.max(1, canvasH - pad * 2)\n          let scale = Math.min(innerW / bbox.w, innerH / bbox.h)\n          scale *= Math.max(1, Number.isFinite(overscan) ? overscan : 1)\n          const tx = pad + (innerW - bbox.w * scale) / 2 - bbox.minX * scale\n          const ty = pad + (innerH - bbox.h * scale) / 2 - bbox.minY * scale\n          return { scale, tx, ty }\n        }\n\n        function lerp(a, b, t) {\n          return a + (b - a) * t\n        }\n\n        function generateSignatureVectorFromReport(r) {\n          const ind = Object.assign({}, r.cff?.indicators || {})\n          const v = {}\n          for (const k of SIGNATURE_KEYS) {\n            v[k] = clamp01(Number(ind[k] ?? 0))\n          }\n          const seedStr = JSON.stringify(v, SIGNATURE_KEYS)\n          const rng = mulberry32(hashStr(seedStr))\n          return { v, rng }\n        }\n\n        function generateRawPolyline(v, rng) {\n          const W = 1080,\n            H = 1080\n          const margin = 110\n          const cx = W / 2,\n            cy = H / 2\n\n          const pseudoHI = clamp01(v.CTF * 0.45 + v.RMD * 0.35 + v.RDX * 0.2)\n\n          const bandW = lerp(560, 880, 1 - v.IFD)\n          const bandH = lerp(170, 380, v.IFD)\n          const bandX1 = cx - bandW / 2,\n            bandX2 = cx + bandW / 2\n          const bandY1 = cy - bandH / 2,\n            bandY2 = cy + bandH / 2\n\n          const steps = Math.floor(lerp(2400, 9000, v.RDX))\n          const baseStep = lerp(0.95, 2.75, v.CTF)\n          const turnGain = lerp(0.006, 0.08, v.AAS)\n          const loopP = lerp(0.01, 0.12, v.RMD)\n          const cohesion = lerp(0.12, 0.74, pseudoHI)\n          const switchP = lerp(0.001, 0.011, v.EDS)\n          const jitter = lerp(0.05, 1.3, pseudoHI)\n\n          function softClamp(nx, ny) {\n            if (nx < bandX1) nx = lerp(nx, bandX1, 0.55)\n            if (nx > bandX2) nx = lerp(nx, bandX2, 0.55)\n            if (ny < bandY1) ny = lerp(ny, bandY1, 0.55)\n            if (ny > bandY2) ny = lerp(ny, bandY2, 0.55)\n            nx = Math.max(margin, Math.min(W - margin, nx))\n            ny = Math.max(margin, Math.min(H - margin, ny))\n            return [nx, ny]\n          }\n\n          const baselineAngle = lerp(-0.2, 0.12, rng())\n          const baselineLen = bandW * 0.84\n          const bx1 = cx - (Math.cos(baselineAngle) * baselineLen) / 2\n          const by1 = cy - (Math.sin(baselineAngle) * baselineLen) / 2\n          const bx2 = cx + (Math.cos(baselineAngle) * baselineLen) / 2\n          const by2 = cy + (Math.sin(baselineAngle) * baselineLen) / 2\n\n          const coresN = 3 + Math.floor(rng() * 3)\n          const cores = []\n          for (let i = 0; i < coresN; i++) {\n            const t = coresN === 1 ? 0 : i / (coresN - 1)\n            const px = bx1 + (bx2 - bx1) * t\n            const py = by1 + (by2 - by1) * t\n            const n = Math.hypot(bx2 - bx1, by2 - by1) || 1\n            const nx = -(by2 - by1) / n\n            const ny = (bx2 - bx1) / n\n            const off = (rng() - 0.5) * bandH * 0.62\n            cores.push({\n              x: px + nx * off,\n              y: py + ny * off,\n              pull: lerp(0.05, 0.4, rng()) * cohesion,\n            })\n          }\n\n          let x = lerp(bandX1, bandX1 + bandW * 0.12, rng())\n          let y = lerp(bandY1, bandY2, rng())\n          let ang = lerp(-0.16, 0.16, rng())\n          let mode = 0\n\n          const history = []\n          const historyCap = 80 + Math.floor(v.RMD * 260)\n          const pts = [{ x, y }]\n\n          for (let i = 0; i < steps; i++) {\n            if (rng() < switchP) mode = (mode + 1 + Math.floor(rng() * 2)) % 3\n\n            let target = cores[Math.floor(rng() * cores.length)]\n            if (history.length > 18 && rng() < loopP) {\n              const h = history[Math.floor(rng() * history.length)]\n              target = { x: h.x, y: h.y, pull: lerp(0.06, 0.48, rng()) * cohesion }\n            }\n\n            const dx = target.x - x,\n              dy = target.y - y\n            const dist = Math.hypot(dx, dy) || 1\n            const tx = (dx / dist) * target.pull\n            const ty = (dy / dist) * target.pull\n\n            const pullAngle = Math.atan2(ty, tx)\n            const delta = Math.atan2(Math.sin(pullAngle - ang), Math.cos(pullAngle - ang))\n\n            const drift = (rng() - 0.5) * (0.02 + 0.028 * v.CTF)\n            const modeGain = mode === 0 ? 0.85 : mode === 1 ? 1.25 : 1.05\n\n            const flick =\n              mode === 1 && rng() < 0.018 ? (rng() < 0.5 ? -1 : 1) * (0.28 + rng() * 0.75) : 0\n\n            ang += drift + delta * turnGain * modeGain + flick\n\n            const breathe = 0.8 + 0.45 * Math.sin(i * 0.01 + rng() * 0.6)\n            let stepLen = baseStep * breathe * (0.9 + rng() * 0.28)\n\n            if (mode === 2) {\n              stepLen *= 0.92\n              ang += (rng() - 0.5) * 0.1\n            }\n\n            let nx2 = x + Math.cos(ang) * stepLen + (rng() - 0.5) * 2 * jitter\n            let ny2 = y + Math.sin(ang) * stepLen + (rng() - 0.5) * 2 * jitter\n            ;[nx2, ny2] = softClamp(nx2, ny2)\n            x = nx2\n            y = ny2\n            pts.push({ x, y })\n\n            if (i % 48 === 0) {\n              history.push({ x, y })\n              if (history.length > historyCap) history.shift()\n            }\n          }\n\n          return pts\n        }\n\n        function resamplePolyline(pts, step) {\n          if (pts.length < 2) return pts.slice()\n          const out = [pts[0]]\n          let acc = 0\n          for (let i = 1; i < pts.length; i++) {\n            let p0 = pts[i - 1]\n            let p1 = pts[i]\n            let dx = p1.x - p0.x,\n              dy = p1.y - p0.y\n            let seg = Math.hypot(dx, dy)\n            if (seg === 0) continue\n\n            while (acc + seg >= step) {\n              const t = (step - acc) / seg\n              const nx = p0.x + dx * t\n              const ny = p0.y + dy * t\n              out.push({ x: nx, y: ny })\n              p0 = { x: nx, y: ny }\n              dx = p1.x - p0.x\n              dy = p1.y - p0.y\n              seg = Math.hypot(dx, dy) || 1\n              acc = 0\n            }\n            acc += seg\n          }\n          out.push(pts[pts.length - 1])\n          return out\n        }\n\n        function chaikinOnce(pts) {\n          if (pts.length < 3) return pts.slice()\n          const fixed = []\n          fixed.push(pts[0])\n          for (let i = 0; i < pts.length - 1; i++) {\n            const p = pts[i],\n              q = pts[i + 1]\n            fixed.push(\n              { x: 0.75 * p.x + 0.25 * q.x, y: 0.75 * p.y + 0.25 * q.y },\n              { x: 0.25 * p.x + 0.75 * q.x, y: 0.25 * p.y + 0.75 * q.y },\n            )\n          }\n          fixed.push(pts[pts.length - 1])\n          return fixed\n        }\n\n        let sigAnimRAF = null\n        let sigHasAnimatedOnce = false\n        function drawSignatureFingerprintStatic(r) {\n          const canvas = $('signatureCanvas')\n          if (!canvas) return\n          const rect = canvas.getBoundingClientRect()\n          if (rect.width < 4 || rect.height < 4) return\n          const out = setupHiDPICanvas(canvas)\n          const ctx = out.ctx\n          const width = out.width\n          const height = out.height\n          ctx.clearRect(0, 0, width, height)\n          ctx.save()\n          // draw full path immediately (no animation)\n          renderSignaturePath(ctx, width, height, r, 1)\n          ctx.restore()\n        }\n\n        function drawSignatureFingerprintAnimated(r) {\n                    if (sigHasAnimatedOnce) return\n          sigHasAnimatedOnce = true\nconst canvas = $('signatureCanvas')\n          if (!canvas) return\n\n          const rect = canvas.getBoundingClientRect()\n          if (rect.width < 4 || rect.height < 4) return\n\n          const out = setupHiDPICanvas(canvas)\n          const ctx = out.ctx\n          const width = out.width\n          const height = out.height\n\n          ctx.clearRect(0, 0, width, height)\n          ctx.fillStyle = '#ffffff'\n          ctx.fillRect(0, 0, width, height)\n\n          const gen = generateSignatureVectorFromReport(r)\n          const v = gen.v\n          const rng = gen.rng\n          const raw = generateRawPolyline(v, rng)\n\n          let pts = resamplePolyline(raw, Number(SIGNATURE_OPTS.resampleStepPx))\n          if (SIGNATURE_OPTS.preChaikin) pts = chaikinOnce(pts)\n\n          const bb = bboxOfPoints(pts)\n          const padRatio = 0.028\n          const basePad = Number(SIGNATURE_OPTS.padPx)\n          const PAD = Math.max(basePad, Math.floor(Math.min(width, height) * padRatio))\n          const fit = fitRectToCanvas(bb, width, height, PAD, Number(SIGNATURE_OPTS.overscan))\n\n          const mapped = pts.map((p) => ({\n            x: Math.max(1, Math.min(width - 1, p.x * fit.scale + fit.tx)),\n            y: Math.max(1, Math.min(height - 1, p.y * fit.scale + fit.ty)),\n          }))\n          ctx.lineWidth = Number(SIGNATURE_OPTS.strokeWidth)\n          ctx.lineCap = 'round'\n          ctx.lineJoin = 'round'\n\n          const start = performance.now()\n          const dur = Math.max(240, Number(SIGNATURE_OPTS.animMs) || 1200)\n\n          if (sigAnimRAF) cancelAnimationFrame(sigAnimRAF)\n\n          function frame(now) {\n            const t = Math.min(1, (now - start) / dur)\n            const count = Math.max(2, Math.floor(mapped.length * t))\n\n            ctx.clearRect(0, 0, width, height)\n            ctx.fillStyle = '#ffffff'\n            ctx.fillRect(0, 0, width, height)\n\n            ctx.globalAlpha = 1\n            const ORANGE =\n              getComputedStyle(document.documentElement).getPropertyValue('--accentE').trim() ||\n              getComputedStyle(document.documentElement).getPropertyValue('--accentD').trim() ||\n              '#f97b17'\n            const YELLOW = '#ffd34a'\n\n            // Fuse-style burn rendering (identity-safe):\n            // - The path/seed/timing are unchanged.\n            // - We only change stroke styling to look like a burning fuse.\n\n            const FUSE_BASE = '#3b2f2a'   // unburnt fuse rope\n            const FUSE_BURNT = '#1f1b17'  // charred trail\n            const GLOW_A = '#ffb33b'      // ember core\n            const GLOW_B = '#ff6a1a'      // ember edge\n\n            // draw ONLY a short \"unburnt\" fuse segment right ahead of the burn head\n            // (so the fuse does not look fully pre-drawn on frame 1)\n            const lookAhead = Math.max(10, Math.floor(mapped.length * 0.03))\n            const startAhead = Math.max(0, count - 1)\n            const endAhead = Math.min(mapped.length, count + lookAhead)\n\n            const baseW = Number(SIGNATURE_OPTS.strokeWidth) || 1.2\n\n            ctx.lineWidth = Math.max(0.9, baseW * 1.05)\n            ctx.lineCap = \"round\"\n            ctx.lineJoin = \"round\"\n            ctx.globalAlpha = 0.88\n            ctx.strokeStyle = FUSE_BASE\n            ctx.beginPath()\n            ctx.moveTo(mapped[startAhead].x, mapped[startAhead].y)\n            for (let i = startAhead + 1; i < endAhead; i++) ctx.lineTo(mapped[i].x, mapped[i].y)\n            ctx.stroke()\n\n            // draw burnt segment (from start to current burn head)\n            ctx.globalAlpha = 1\n            ctx.strokeStyle = FUSE_BURNT\n            ctx.lineWidth = Math.max(0.8, baseW * 0.92)\n            ctx.beginPath()\n            ctx.moveTo(mapped[0].x, mapped[0].y)\n            for (let i = 1; i < count; i++) ctx.lineTo(mapped[i].x, mapped[i].y)\n            ctx.stroke()\n\n            // burn head position\n            const tip = mapped[Math.max(0, count - 1)]\n            const tipX = tip.x\n            const tipY = tip.y\n\n            // \"ember\" at the burn head (tip)\n            if (t < 1) {\n                          // \"ember\" at the burn head (tip)\n                          const emberR = 4.0\n            ctx.save()\n            ctx.globalCompositeOperation = 'lighter'\n            const grd = ctx.createRadialGradient(tipX, tipY, 0, tipX, tipY, emberR * 6)\n            grd.addColorStop(0, GLOW_A)\n            grd.addColorStop(0.35, GLOW_B)\n            grd.addColorStop(1, 'rgba(255,106,26,0)')\n            ctx.fillStyle = grd\n            ctx.beginPath()\n            ctx.arc(tipX, tipY, emberR * 6, 0, Math.PI * 2)\n            ctx.fill()\n            ctx.restore()\n            }\n\n            // Sparkler effect at the drawing tip (Pen Tip)\n            // IMPLEMENTATION NOTE (v35 identity-safe):\n            // - This does NOT touch path generation, seed, timing, or coordinate accumulation.\n            // - It only uses the *current tip* position already produced by the v35 draw loop.\n            //\n            // Visual goal:\n            // - Not a soft circle, but a short, bright streak that flashes 1\u20132 frames\n            // - Additive only at the flash moment (no lingering glow)\n            // - Few sparks (4\u20137) in warm palette\n            // - Exists ONLY while drawing, then fully disappears\n\n            if (!frame.__sparks) {\n              frame.__sparks = []\n              frame.__sparkTick = 0\n              // deterministic-ish RNG anchored to the signature vector (doesn't affect the line)\n              frame.__sparkRng = mulberry32(hashStr('spark:' + JSON.stringify(v, SIGNATURE_KEYS)))\n            }\n\n            const sparks = frame.__sparks\n            if (t >= 1) sparks.length = 0\n            const rand = frame.__sparkRng\n\n            // Spawn a tiny radial burst EVERY frame while drawing.\n            // Keeping it sparse ensures it reads as a pen-tip tool, not decoration.\n            if (t < 1) {\n              frame.__sparkTick++\n              const burstN = 2 + Math.floor(rand() * 5) // 2..6 (2x density)\n              for (let k = 0; k < burstN; k++) {\n                const ang = rand() * Math.PI * 2\n                const spd = 2.2 + rand() * 3.2\n                const vx = Math.cos(ang) * spd\n                const vy = Math.sin(ang) * spd\n\n                // life is intentionally very short; flash is handled below\n                const life = 220 + rand() * 180 // 220..400ms (shorter, calmer)\n\n                // Varied travel lengths (some short, some long) so sparks don't read as identical dots.\n                // NOTE: this does NOT touch the signature path/seed logic; it only affects spark rendering.\n                const baseLen = 7\n                let len = baseLen * (0.70 + rand() * 1.60) // base streak length\n\n                // (REQUEST 1) long-flyer ratio: 22% -> 50%\n                // Half of particles become long flyers so \"dot\" perception drops sharply.\n                const isLong = rand() < 0.50\n                if (isLong) len *= 1.05 + rand() * 0.25\n\n                // (REQUEST 2) per-particle thickness: all different\n                // - short sparks: relatively thicker\n                // - long sparks: relatively thinner\n                // - even within the same type, add micro variation to avoid repeating patterns\n                const wShort = 0.70 + rand() * 0.55 // ~0.70..1.25\n                const wLong = 0.30 + rand() * 0.30  // ~0.30..0.60\n                const wJit = 0.90 + rand() * 0.22   // +/- ~11%\n                const w = (isLong ? wLong : wShort) * wJit\n\n                // per-particle subtle length jitter so it's not uniform over its lifetime\n                const lenJ = 0.85 + rand() * 0.30\n\n                // hard cap so long streaks never feel \\\"too long\\\" (max ~50% of previous visual)\n                len = Math.min(len, 12.5)\n\n                const pick = rand()\n                const palette = [\n                  '#3b82f6', // blue\n                  '#60a5fa', // light blue\n                  '#22d3ee', // cyan\n                  '#ffd34a', // yellow\n                  '#ff7a1a', // orange\n                  '#ff2a2a', // red\n                  '#b90d11', // deep red\n                  '#c026d3', // purple\n                  '#ff4fd8', // magenta\n                ]\n\n                // two-tone spark colors (head/tail) for richer multi-color feel\n                const col = palette[Math.floor(rand() * palette.length)]\n                const col2 = palette[Math.floor(rand() * palette.length)]\n\n                // minimal jitter so it never becomes a perfect ring\n                const jx = (rand() - 0.5) * 0.8\n                const jy = (rand() - 0.5) * 0.8\n\n                sparks.push({\n                  x: tipX + jx,\n                  y: tipY + jy,\n                  px: tipX + jx,\n                  py: tipY + jy,\n                  vx,\n                  vy,\n                  born: now,\n                  life,\n                  w,\n                  len,\n                  lenJ,\n                  col,\n                  col2,\n                })\n              }\n            }\n\n            // Central tip flash (1-frame)\n            // - reinforces the perception: spark passes, line remains\n            if (t < 1) {\n              ctx.save()\n              ctx.globalCompositeOperation = 'lighter'\n              ctx.globalAlpha = 0.92\n              // deterministic color pick per frame\n              const fp = rand()\n              const fcol = fp < 0.20 ? '#ffd34a' : fp < 0.40 ? '#ff7a1a' : fp < 0.60 ? '#ff2a2a' : fp < 0.80 ? '#3b82f6' : '#22d3ee'\n              ctx.strokeStyle = fcol\n              ctx.lineCap = 'round'\n              ctx.lineWidth = 1.25\n              // tiny star-like burst: 4 short rays\n              const rr = 7\n              ctx.beginPath()\n              ctx.moveTo(tipX - rr, tipY)\n              ctx.lineTo(tipX + rr, tipY)\n              ctx.moveTo(tipX, tipY - rr)\n              ctx.lineTo(tipX, tipY + rr)\n              ctx.stroke()\n              ctx.restore()\n            }\n\n// Update + draw sparks\n            // Key difference vs the failed \"yellow circles\":\n            // - We draw streak segments (short line segments)\n            // - We use additive blending ONLY in the first 1\u20132 frames of each particle\n            // - No persistent shadow blur or large gradients\n            ctx.save()\n            ctx.lineCap = 'round'\n            ctx.lineJoin = 'round'\n\n            for (let i = sparks.length - 1; i >= 0; i--) {\n              const p = sparks[i]\n              const age = now - p.born\n              if (age >= p.life) {\n                sparks.splice(i, 1)\n                continue\n              }\n\n              const u = age / p.life\n\n              // motion (spark flies outward, then fades)\n              // store previous position to draw a true travel streak (not a static line)\n              p.px = p.x\n              p.py = p.y\n\n              const drag = 0.90\n              p.vx *= drag\n              p.vy = p.vy * drag + 0.004\n              p.x += p.vx\n              p.y += p.vy\n\n              // flash window: first ~1\u20132 frames at 60Hz\n              const flash = age < 42\n\n              // blend mode: additive ONLY during flash\n              ctx.globalCompositeOperation = flash ? 'lighter' : 'source-over'\n\n              // alpha drops extremely fast; after flash it's faint and dying\n              const a = flash ? 0.88 : Math.max(0, Math.pow(1 - u, 0.85) * 0.46)\n              if (a <= 0.01) continue\n              ctx.globalAlpha = a              // draw TRAVEL streak (spark whooshes from tip outward)\n              // 1) a short motion streak from previous -> current position\n              const dxm = p.x - p.px\n              const dym = p.y - p.py\n              const mmag = (dxm * dxm + dym * dym) ** 0.5 || 1\n\n              // Build a visible travel streak even when per-frame movement is tiny.\n              // If dx/dy is too small (appears as a dot), fall back to velocity direction.\n              let dirx = dxm\n              let diry = dym\n              if (mmag < 0.35) {\n                dirx = p.vx\n                diry = p.vy\n              }\n              const dmag = Math.hypot(dirx, diry) || 1\n              const ux = dirx / dmag\n              const uy = diry / dmag\n\n              // Use particle-specific streak length (with slight jitter) so some sparks fly longer.\n              const tailLen = p.len * (p.lenJ || 1)\n              const x1t = p.x - ux * tailLen\n              const y1t = p.y - uy * tailLen\n\n              // multi-color travel streak using a small linear gradient (more color separation)\n              const g = ctx.createLinearGradient(x1t, y1t, p.x, p.y)\n              g.addColorStop(0, 'rgba(0,0,0,0)')\n              g.addColorStop(0.15, p.col2)\n              g.addColorStop(0.65, p.col)\n              g.addColorStop(1, p.col)\n              ctx.strokeStyle = g\n              ctx.lineWidth = flash ? p.w * 1.00 : p.w * 0.88\n              ctx.beginPath()\n              ctx.moveTo(x1t, y1t)\n              ctx.lineTo(p.x, p.y)\n              ctx.stroke()\n\n              // 2) a tiny bright head flash for 1\u20132 frames, makes motion obvious on white background\n              if (flash) {\n                ctx.fillStyle = p.col\n                ctx.globalAlpha = Math.min(1, a + 0.10)\n                ctx.beginPath()\n                ctx.arc(p.x, p.y, 1.15 + p.w * 0.45, 0, Math.PI * 2)\n                ctx.fill()\n              }\n            }\n            ctx.restore()\n\n            // Stop cleanly at the end (no lingering ember or sparks on the last frame).\n            if (t < 1) {\n              sigAnimRAF = requestAnimationFrame(frame)\n            }\n          }\n          sigAnimRAF = requestAnimationFrame(frame)\n        }\n\n        /* =========================================================\n       Charts setup\n    ========================================================= */\n        const chartsById = Object.create(null)\n        const chartAnimators = Object.create(null)\n        const chartAnimatedOnce = Object.create(null)\n\n        const chartIO =\n          'IntersectionObserver' in window\n            ? new IntersectionObserver(onChartEnter, {\n                root: null,\n                threshold: 0.18,\n                rootMargin: '120px 0px',\n              })\n            : null\n        // Charts\n\n        function safeChart(id, config) {\n          const el = $(id)\n          if (!el || !window.Chart) return null\n          if (chartsById[id]) {\n            try {\n              chartsById[id].destroy()\n            } catch (_e) {}\n            delete chartsById[id]\n          }\n          const c = new Chart(el, config)\n          chartsById[id] = c\n          return c\n        }\n\n        function baseChartOptions(animate) {\n          return {\n            responsive: true,\n            maintainAspectRatio: false,\n            animation: animate ? { duration: CHART_ANIM_MS } : { duration: 0 },\n            interaction: { mode: 'nearest', intersect: false },\n            plugins: {\n              legend: {\n                display: true,\n                position: 'top',\n                labels: { usePointStyle: true, pointStyle: 'circle', boxWidth: 8, boxHeight: 8 },\n              },\n              tooltip: { enabled: true },\n            },\n          }\n        }\n\n        function doughnutOptions(animate) {\n          const base = baseChartOptions(animate)\n          return {\n            ...base,\n            rotation: -90,\n            circumference: 360,\n            animation: animate\n              ? { duration: CHART_ANIM_MS, delay: 0, animateRotate: true, animateScale: false }\n              : { duration: 0 },\n            plugins: { ...base.plugins, legend: { ...base.plugins.legend, position: 'bottom' } },\n          }\n        }\n\n        const BAR_FIXED_VERTICAL = {\n          barThickness: 14,\n          maxBarThickness: 14,\n          categoryPercentage: 0.8,\n          barPercentage: 0.9,\n          borderWidth: 0,\n          borderRadius: { topLeft: 4, topRight: 4, bottomLeft: 0, bottomRight: 0 },\n          borderSkipped: false,\n        }\n\n        const BAR_FIXED_HORIZONTAL = {\n          barThickness: 14,\n          maxBarThickness: 14,\n          categoryPercentage: 0.8,\n          barPercentage: 0.9,\n          borderWidth: 0,\n          borderRadius: { topLeft: 0, bottomLeft: 0, topRight: 4, bottomRight: 4 },\n          borderSkipped: false,\n        }\n\n        const DONUT_FIXED = {\n          cutout: '62%',\n          radius: '92%',\n          borderWidth: 0,\n          hoverOffset: 0,\n        }\n\n        function mountChartDeferred(id, makeBaseConfig, animateNow) {\n          const el = $(id)\n          if (!el) return\n\n          safeChart(id, makeBaseConfig(false))\n\n          if (chartIO) {\n            chartAnimators[id] = animateNow\n            chartIO.observe(el)\n          } else {\n            setTimeout(\n              () => animateNow(),\n              (IS_MOBILE ? MOBILE_CHART_START_DELAY : 0) + CHART_DELAY_MS,\n            )\n          }\n        }\n\n        function onChartEnter(entries) {\n          entries.forEach((ent) => {\n            if (!ent.isIntersecting) return\n            const canvas = ent.target\n            const id = canvas && canvas.id\n            if (!id) return\n            if (chartAnimatedOnce[id]) return\n\n            chartAnimatedOnce[id] = true\n            chartIO.unobserve(canvas)\n\n            const fn = chartAnimators[id]\n            if (typeof fn === 'function') {\n              setTimeout(() => fn(), (IS_MOBILE ? MOBILE_CHART_START_DELAY : 0) + CHART_DELAY_MS)\n            }\n          })\n        }\n\n        function animateChartData(id, applyRealData) {\n          const c = chartsById[id]\n          if (!c) return\n          applyRealData(c)\n          c.options.animation = { duration: CHART_ANIM_MS, delay: 0 }\n          c.update()\n        }\n\n        const RADAR_VALUE_IN_POINT_LABEL = false\n\n        function registerAllCharts(r) {\n          const mix = getMixFromReport(r)\n          const conf = getConfidenceIndex01(r)\n\n          const relMapped =\n            r.ai?.detection_reliability_band === 'HIGH'\n              ? 0.9\n              : r.ai?.detection_reliability_band === 'MEDIUM'\n                ? 0.6\n                : 0.35\n\n          const decision = r.ai?.final_classification || r.ai?.determination || 'Human'\n\n          const arcDims = Array.isArray(r.rsl?.dimensions) ? r.rsl.dimensions : []\n          const arcLabels = arcDims.map((d) => String(d.code || '').trim()).filter(Boolean)\n          const arcVals = arcDims.map((d) => Number(d.score ?? 0))\n\n          const cffOrder = ['AAS', 'CTF', 'RMD', 'RDX', 'EDS', 'IFD']\n          const cffInd = r.cff?.indicators || {}\n\n          const DONUT_SPIN_ANIM = {\n            circumference: { duration: CHART_ANIM_MS, from: 0 },\n            rotation: { duration: CHART_ANIM_MS, from: -450 },\n          }\n\n          /* =========================================================\n         chartMixAgency -> Reasoning Control Distribution\n         NOTE: center label should show HUMAN SHARE (not confidence).\n      ========================================================= */\n\n          mountChartDeferred(\n            'chartMixAgency',\n            (animate) => ({\n              type: 'doughnut',\n              data: {\n                labels: ['Human', 'Hybrid', 'AI'],\n                datasets: [\n                  {\n                    data: [0, 0, 0],\n                    ...DONUT_FIXED,\n                    backgroundColor: [THEME.accentA, THEME.accentC, THEME.accentD],\n                  },\n                ],\n              },\n              options: {\n                ...doughnutOptions(animate),\n                plugins: {\n                  ...doughnutOptions(animate).plugins,\n                  // Top: determination label (e.g., Human)\n                  // Bottom: Human share from mix_ratio/distribution (e.g., 82%)\n                  centerText: { top: decision, bottom: (pctTripletFromMix(mix)[0] + '%') },\n                },\n              },\n            }),\n            () =>\n              animateChartData('chartMixAgency', (c) => {\n                const mix = getMixFromReport(r)\n                const decision = String(r.ai?.final_classification ?? r.ai?.determination ?? 'Human')\n                c.data.datasets[0].data = pctTripletFromMix(mix)\n                // Keep center label aligned to the chart's Human portion.\n                c.options.plugins.centerText = { top: decision, bottom: (pctTripletFromMix(mix)[0] + '%') }\n              }),\n          )\n\n          /* =========================================================\n         2-2) Structural Control Signals (Agency Indicators)\n         - Keeps the page resilient: prevents ReferenceError when rendering charts.\n      ========================================================= */\n          const contribKeys = [\n            'structural_variance',\n            'human_rhythm_index',\n            'transition_flow',\n            'revision_depth',\n          ]\n          const contribLabels = [\n            'Structural variance',\n            'Human rhythm index',\n            'Transition flow integrity',\n            'Revision depth signal',\n          ]\n          const contribSrc = r && r.ai && r.ai.signal_contributions ? r.ai.signal_contributions : {}\n          const contribVals = contribKeys.map((k) => clamp01(Number(contribSrc[k] ?? 0)))\n\n          mountChartDeferred(\n            'chartAuthSignals',\n            (animate) => ({\n              type: 'bar',\n              data: {\n                labels: contribLabels,\n                datasets: [\n                  {\n                    label: 'contribution (0 to 1)',\n                    data: contribLabels.map(() => 0),\n                    ...BAR_FIXED_HORIZONTAL,\n                    backgroundColor: THEME.accentB,\n                  },\n                ],\n              },\n              options: {\n                ...baseChartOptions(animate),\n                indexAxis: 'y',\n                animation: animate\n                  ? {\n                      duration: CHART_ANIM_MS,\n                      delay: (ctx) => (ctx.type === 'data' ? 140 + ctx.dataIndex * 90 : 0),\n                    }\n                  : { duration: 0 },\n                plugins: {\n                  ...baseChartOptions(animate).plugins,\n                  barValueLabels: { format: 'float2', textColor: THEME.text || '#0f172a' },\n                },\n                scales: {\n                  x: { min: 0, max: 0.4, grid: { color: 'rgba(148,163,184,.22)' } },\n                  y: {\n                    grid: { display: false },\n                  },\n                },\n              },\n            }),\n            () =>\n              animateChartData('chartAuthSignals', (c) => {\n                c.data.datasets[0].data = contribVals.slice()\n              }),\n          )\n\n          mountChartDeferred(\n            'chartCffRadar',\n            (animate) => ({\n              type: 'radar',\n              data: {\n                labels: cffOrder,\n                datasets: [\n                  {\n                    label: 'CFF Indicator',\n                    data: cffOrder.map(() => 0),\n                    fill: true,\n                    backgroundColor: _rgba(THEME.accentC, 0.14, '32,203,194'),\n                    borderColor: THEME.accentC,\n                    pointBackgroundColor: THEME.accentC,\n                    borderWidth: 2,\n                    pointRadius: 3,\n                    pointHoverRadius: 3,\n                    pointBorderWidth: 0,\n                  },\n                ],\n              },\n              options: {\n                ...baseChartOptions(animate),\n                plugins: {\n                  ...baseChartOptions(animate).plugins,\n                  legend: { ...baseChartOptions(animate).plugins.legend, position: 'bottom' },\n                  radarValueLabels: false,\n                },\n                scales: {\n                  r: {\n                    min: 0,\n                    max: 1,\n                    ticks: { display: false, backdropColor: 'transparent' },\n                    pointLabels: {\n                      padding: 8,\n                      font: { size: 10, weight: '500' },\n                      color: THEME.text || '#0f172a',\n                    },\n                    grid: { color: 'rgba(148,163,184,.22)' },\n                    angleLines: { color: 'rgba(148,163,184,.22)' },\n                  },\n                },\n              },\n            }),\n            () =>\n              animateChartData('chartCffRadar', (c) => {\n                const vals = cffOrder.map((k) => Number(cffInd[k] ?? 0))\n                c.data.datasets[0].data = vals.slice()\n                c.data.labels = cffOrder.slice()\n                c.options.plugins.radarValueLabels = false\n              }),\n          )\n\n          mountChartDeferred(\n            'chartRslBars',\n            (animate) => ({\n              type: 'line',\n              data: {\n                datasets: (() => {\n                  const curvePts =\n                    r?.rsl?.charts?.cohort_positioning?.curve_points &&\n                    Array.isArray(r.rsl.charts.cohort_positioning.curve_points)\n                      ? r.rsl.charts.cohort_positioning.curve_points\n                      : [\n                          { x: 0.0, y: 2 },\n                          { x: 0.5, y: 6 },\n                          { x: 1.0, y: 14 },\n                          { x: 1.5, y: 26 },\n                          { x: 2.0, y: 30 },\n                          { x: 2.5, y: 45 },\n                          { x: 3.0, y: 58 },\n                          { x: 3.5, y: 42 },\n                          { x: 4.0, y: 22 },\n                          { x: 4.5, y: 10 },\n                          { x: 5.0, y: 4 },\n                        ]\n\n                  const fri = Math.max(0, Math.min(5, Number(r?.rsl?.fri ?? 0)))\n\n                  const yAtX = (x) => {\n                    if (!curvePts.length) return 0\n                    if (x <= curvePts[0].x) return Number(curvePts[0].y ?? 0)\n                    for (let i = 1; i < curvePts.length; i++) {\n                      const a = curvePts[i - 1],\n                        b = curvePts[i]\n                      if (x <= b.x) {\n                        const t = (x - a.x) / (b.x - a.x || 1)\n                        return a.y + (b.y - a.y) * t\n                      }\n                    }\n                    return Number(curvePts[curvePts.length - 1].y ?? 0)\n                  }\n\n                  const curPt = { x: fri, y: yAtX(fri) }\n\n                  const baseCurve = animate ? curvePts : curvePts.map((p) => ({ x: p.x, y: 0 }))\n\n                  return [\n                    {\n                      label: 'Cohort distribution',\n                      data: baseCurve,\n                      parsing: false,\n                      borderColor: THEME.accentD || 'rgba(250,187,5,0.95)',\n                      backgroundColor: _rgba(THEME.accentD || '#fabb05', 0.1, '250,187,5'),\n                      fill: true,\n                      tension: 0.45,\n                      borderWidth: 2,\n                      pointRadius: 0,\n                      pointHoverRadius: 0,\n                    },\n\n                    {\n                      label: 'Current',\n                      data: [curPt],\n                      parsing: false,\n                      showLine: false,\n                      pointRadius: 0 /* revealed after delay */,\n                      pointHoverRadius: 6,\n                      pointBackgroundColor: THEME.accentD || '#fabb05',\n                      pointBorderColor: '#fabb05',\n                      pointBorderWidth: 0,\n                    },\n                  ]\n                })(),\n              },\n              options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                devicePixelRatio: Math.min(2, window.devicePixelRatio || 1),\n                animation: animate ? { duration: CHART_ANIM_MS, delay: 0 } : { duration: 0 },\n                layout: { padding: { top: 10, right: 14, bottom: 12, left: 14 } },\n\n                interaction: { mode: 'nearest', intersect: true },\n\n                scales: {\n                  x: {\n                    type: 'linear',\n                    min: 0,\n                    max: 5,\n                    grid: { color: 'rgba(226,232,240,0.55)' },\n                    ticks: {\n                      stepSize: 1,\n                      color: THEME.text || '#0f172a',\n                    },\n                  },\n                  y: {\n                    min: 0,\n                    max: 100,\n                    grid: { color: 'rgba(226,232,240,0.55)' },\n                    ticks: {\n                      stepSize: 20,\n                      callback: (v) => `${v}%`,\n                      color: THEME.text || '#0f172a',\n                    },\n                  },\n                },\n                elements: {\n                  line: { borderJoinStyle: 'round' },\n                },\n                plugins: {\n                  ...baseChartOptions(animate).plugins,\n\n                  pulseCurrentPoint: {\n                    datasetIndex: 1,\n                    rings: 4,\n                    maxR: 52,\n                    periodMs: 2500,\n                    startDelayMs: 0,\n                    fadeInMs: 420,\n                    maxAlpha: 0.26,\n                    lineWidth: 2,\n                  },\n                  legend: {\n                    display: true,\n                    position: 'bottom',\n                    align: 'center',\n                    labels: {\n                      filter: (item) => item.datasetIndex === 1,\n                      usePointStyle: true,\n                      pointStyle: 'circle',\n                      boxWidth: 8,\n                      boxHeight: 8,\n                      padding: 10,\n                      font: { size: 11, weight: '500' },\n                      color: THEME.muted || '#0F172A',\n                    },\n                  },\n                  tooltip: {\n                    enabled: true,\n                    displayColors: false,\n                    filter: (ctx) => ctx.datasetIndex === 1,\n                    callbacks: {\n                      title: () => '',\n                      label: (ctx) => {\n                        const x = Number(ctx.parsed?.x ?? 0)\n                        const p = Number(r?.rsl?.percentile ?? r?.rsl?.percentile_0to1 ?? 0)\n                        const top = Math.max(0, Math.min(100, Math.round((1 - p) * 100)))\n                        const topTxt = `Top ${top}%`\n                        return [`\u25cf Current \u00b7 ${topTxt}`, `FRI \u00b7 ${x.toFixed(2)} / 5`]\n                      },\n                    },\n                  },\n                },\n              },\n            }),\n            () => {\n              animateChartData('chartRslBars', (c) => {\n                if (!c) return\n\n                const curvePts =\n                  r?.rsl?.charts?.cohort_positioning?.curve_points &&\n                  Array.isArray(r.rsl.charts.cohort_positioning.curve_points)\n                    ? r.rsl.charts.cohort_positioning.curve_points\n                    : c.data?.datasets?.[0]?.data || []\n\n                const fri = Math.max(0, Math.min(5, Number(r?.rsl?.fri ?? 0)))\n\n                const yAtX = (x) => {\n                  if (!curvePts.length) return 0\n                  if (x <= curvePts[0].x) return Number(curvePts[0].y ?? 0)\n                  for (let i = 1; i < curvePts.length; i++) {\n                    const a = curvePts[i - 1],\n                      b = curvePts[i]\n                    if (x <= b.x) {\n                      const t = (x - a.x) / (b.x - a.x || 1)\n                      return a.y + (b.y - a.y) * t\n                    }\n                  }\n                  return Number(curvePts[curvePts.length - 1].y ?? 0)\n                }\n\n                const curPt = { x: fri, y: yAtX(fri) }\n\n                if (c.data?.datasets?.[0]) c.data.datasets[0].data = curvePts\n                if (c.data?.datasets?.[1]) {\n                  c.data.datasets[1].data = [curPt]\n                  c.data.datasets[1].pointRadius = 6\n                }\n\n                try {\n                  if (c && c.data && c.data.datasets && c.data.datasets[1]) {\n                    c.data.datasets[1].pointRadius = 0\n                    c.$currentRevealTimer && clearTimeout(c.$currentRevealTimer)\n                    c.$currentRevealTimer = setTimeout(() => {\n                      try {\n                        c.data.datasets[1].pointRadius = 6\n                        c.update()\n                      } catch (_e) {}\n                    }, 1000)\n                  }\n                } catch (_e) {}\n              })\n            },\n          )\n\n          mountChartDeferred(\n            'chartRslRadar',\n            (animate) => ({\n              type: 'radar',\n              data: {\n                labels: arcLabels,\n                datasets: [\n                  {\n                    label: 'RSL profile',\n                    data: arcLabels.map(() => 0),\n                    fill: true,\n                    backgroundColor: THEME.pillB,\n                    borderColor: THEME.accentB,\n                    borderWidth: 2,\n                    pointRadius: 3,\n                    pointHoverRadius: 3,\n                    pointBackgroundColor: THEME.accentB,\n                    pointBorderWidth: 0,\n                  },\n                ],\n              },\n              options: {\n                ...baseChartOptions(animate),\n                plugins: {\n                  ...baseChartOptions(animate).plugins,\n                  legend: { ...baseChartOptions(animate).plugins.legend, position: 'bottom' },\n                  radarValueLabels: false,\n                },\n                scales: {\n                  r: {\n                    min: 0,\n                    max: 6,\n                    ticks: { display: false, backdropColor: 'transparent' },\n                    pointLabels: {\n                      padding: 8,\n                      font: { size: 10, weight: '500' },\n                      color: THEME.text || '#0f172a',\n                    },\n                    grid: { color: 'rgba(148,163,184,.22)' },\n                    angleLines: { color: 'rgba(148,163,184,.22)' },\n                  },\n                },\n              },\n            }),\n            () =>\n              animateChartData('chartRslRadar', (c) => {\n                c.data.datasets[0].data = arcVals.slice()\n                c.options.plugins.radarValueLabels = false\n              }),\n          )\n          const tracks = Array.isArray(r.role_fit?.track_scores) ? r.role_fit.track_scores : []\n          const roles = tracks.map((t) => String(t.track || ''))\n          const roleVals = tracks.map((t) =>\n            clamp01((typeof t.pct === 'number' ? t.pct : Number(t.pct || 0)) / 100),\n          )\n          mountChartDeferred(\n            'chartHrFit',\n            (animate) => ({\n              type: 'bar',\n              data: {\n                labels: roles,\n                datasets: [\n                  {\n                    label: 'fit (0 to 1)',\n                    data: roles.map(() => 0),\n                    ...BAR_FIXED_VERTICAL,\n                    backgroundColor: THEME.accentD,\n                  },\n                ],\n              },\n              options: {\n                ...baseChartOptions(animate),\n                plugins: {\n                  ...baseChartOptions(animate).plugins,\n                  barValueLabels: { format: 'float2', textColor: THEME.text || '#0f172a' },\n                },\n                scales: {\n                  y: { min: 0, max: 1, grid: { color: 'rgba(148,163,184,.22)' } },\n                  x: { grid: { display: false } },\n                },\n              },\n            }),\n            () =>\n              animateChartData('chartHrFit', (c) => {\n                c.data.datasets[0].data = roleVals.slice()\n              }),\n          )\n        }\n\n        /* =========================================================\n       Tabs: click scroll + active\n    ========================================================= */\n\n        /* =========================================================\n       Role Fit Inference Flow: staged reveal (v1)\n       - Reveals SVG steps from top to bottom once the flow becomes visible\n       - Uses existing SVG markup: .flowStep[data-step], .flowLine[data-line]\n    ========================================================= */\n\n        function initSignatureOnceOnView(){\n          if (sigHasAnimatedOnce) return;\n\n          const target =\n            document.querySelector(\"#signatureWrap\") ||\n            document.querySelector(\"#signatureCanvas\") ||\n            null;\n          if(!target) return;\n\n          const runOnce = () => {\n            if (sigHasAnimatedOnce) return;\n            try { drawSignatureFingerprintAnimated(REPORT); } catch(_e) {}\n          };\n\n          if (\"IntersectionObserver\" in window){\n            const io = new IntersectionObserver((entries)=>{\n              for(const ent of entries){\n                if(ent.isIntersecting){\n                  runOnce();\n                  try{ io.disconnect(); }catch(e){}\n                  break;\n                }\n              }\n            }, { threshold: 0.35 });\n            io.observe(target);\n          } else {\n            // fallback: first scroll into view\n            const onScroll = () => {\n              const r = target.getBoundingClientRect();\n              const vh = window.innerHeight || document.documentElement.clientHeight;\n              if(r.top < vh*0.75 && r.bottom > vh*0.25){\n                runOnce();\n                window.removeEventListener(\"scroll\", onScroll);\n              }\n            };\n            window.addEventListener(\"scroll\", onScroll, { passive:true });\n            onScroll();\n          }\n        }\n\n        /* =========================================================\n           Boot\n        ========================================================= */\n\n        function boot() {\n          try {\n            renderReport(REPORT)\n            registerAllCharts(REPORT)\n            initSignatureOnceOnView()\n            __np_initRoleFitFlowOnView()\n\n            let sigResizeT = null\n            window.addEventListener(\n              'resize',\n              () => {\n                if (sigResizeT) window.clearTimeout(sigResizeT)\n                sigResizeT = window.setTimeout(() => {\n                  // Cognitive Fingerprint: no resize-triggered replay\n                }, 120)\n              },\n              { passive: true },\n            )\n          } catch (e) {\n            NP_DEBUG && console.error('Boot error:', e)\n          }\n        }\n\n        window.setReport = function (reportObject) {\n          window.report = reportObject\n          window.renderNeuPrint(reportObject)\n        }\n\n        boot()\n      } // end window.renderNeuPrint\n\n      ;(function () {\n    function getReportData(){\n      try{\n        if(typeof window !== 'undefined' && window.REPORT && typeof window.REPORT === 'object'){\n          return window.REPORT;\n        }\n        const el = document.getElementById('dev-report-json');\n        if(el && el.textContent){\n          return JSON.parse(el.textContent);\n        }\n      }catch(e){\nNP_DEBUG && console.error('[NeuPrint] Failed to load report data', e);\n      }\n      return null;\n    }\n        function run() {\n          const data = getReportData() || window.report || window.DEV_REPORT || null\n          if (data) {\n            window.report = data\n            if (!window.REPORT) window.REPORT = data\n            window.renderNeuPrint(data)\n          }\n        }\n        function ensureChartJs(){\n          if(window.Chart) return Promise.resolve();\n          return new Promise(function(resolve, reject){\n            var s=document.createElement('script');\n            s.src='https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js';\n            s.async=true;\n            s.onload=function(){resolve();};\n            s.onerror=function(){reject(new Error('Chart.js load failed'));};\n            document.head.appendChild(s);\n          });\n        }\n        function boot(){\n          ensureChartJs().then(run).catch(function(e){\n            console.error('[NeuPrint] Chart.js load failed:', e);\n            try{ run(); }catch(_e){}\n          });\n        }\n        if (document.readyState === 'loading') {\n          document.addEventListener('DOMContentLoaded', boot)\n        } else {\n          boot()\n        }\n      })()\n    \n})();\n</script>\n  \n    <!-- Embedded reference payload (development only). Production builds should inject window.REPORT from the backend. -->\n    <textarea id=\"dev-report-json\" style=\"display:none\" aria-hidden=\"true\">\n      {\n        \"engine_version\": \"1.1\",\n        \"assessment_id\": \"NP-2025-0314-0007\",\n        \"input_language\": \"EN\",\n        \"generated_at_utc\": \"2025-03-14T10:22:11Z\",\n        \"_schema\": {\n          \"meta\": \"Branding, verification, and header metadata used across the page.\",\n          \"hero\": \"Top summary area chips and hero quote. Values populate the header and KPI chips.\",\n          \"rsl\": \"Reasoning Structure Layer. percentile_0to1 (0-1) used to compute Top (100 - pct*100)%.\",\n          \"cff\": \"Cognitive Fingerprint Framework. observed_patterns.primary/secondary show the two patterns.\",\n          \"agency\": \"Reasoning Control / Structural Agency section and charts.\",\n          \"role_fit\": \"Role Fit section including track scores and inference flow labels.\"\n        },\n        \"meta\": {\n          \"product_name\": \"NeuPrint\",\n          \"engine_label\": \"NeuPrint Cognitive Forensics Engine v1.1\",\n          \"signed_note\": \"This determination is structurally signed and referenceable.\",\n          \"verify_url\": \"https://neuprint.ai/verify\",\n          \"verification_anchor_note\": \"QR code shown represents the verification anchor.\",\n          \"verification_id\": \"NP-2025-0314-0007\",\n          \"qr_alt\": \"QR placeholder\"\n        },\n        \"hero\": {\n          \"title\": \"Structural Reference for Human Reasoning\",\n          \"description\": \"NeuPrint provides a decision-grade structural reference that determines whether reasoning control remained with the human under AI-assisted conditions.\",\n          \"chips\": {\n            \"rsl_level\": \"L4 Integrated\",\n            \"determination\": \"Reasoning Simulator\",\n            \"fri\": 3.72,\n            \"control\": \"Human\",\n            \"role_fit\": \"Strategy\u00b7Analysis\u00b7Policy\",\n            \"confidence_index\": 0.88\n          },\n          \"decision_compression_quote\": \"Demonstrates exploratory reasoning that converts observation into cross-domain conceptual inquiry, but prioritizes ideational expansion over evaluative convergence, indicating the need to reinforce counterfactual testing and disciplined conclusion consolidation.\"\n        },\n        \"rsl\": {\n          \"section_title\": \"1. Reasoning Structure Layer (RSL)\",\n          \"section_lead\": \"This section shows how your thinking was organized in this writing, and what you can improve next.\",\n          \"overall_level\": \"L4\",\n          \"overall_label\": \"Integrated\",\n          \"overall_level_display\": \"L4 Integrated\",\n          \"overall_level_note\": \"Multiple reasoning dimensions coordinated into a stable, non-dominant structure.\",\n          \"fri_label\": \"Final Reasoning Index\",\n          \"fri\": 3.72,\n          \"fri_note\": \"Your reasoning structure is stable in most situations. Connections and evaluations usually remain consistent.\",\n          \"percentile_0to1\": 0.76,\n          \"cohort_placement_display\": \"Top 24%\",\n          \"cohort_note\": \"This position reflects consistently structured reasoning relative to comparable peers.\",\n          \"stability_index\": 0.89,\n          \"stability_note\": \"Your reasoning structure remains stable even with minor wording changes.\",\n          \"summary\": {\n            \"title\": \"RSL Summary\",\n            \"one_line\": \"Connects writers, history, and ideas over time but stops short of fully tracing one line to its end.\",\n            \"paragraph\": \"Thinking moves by linking personal reflection with historical patterns and named examples. Attention shifts across time, returning to earlier ideas with added nuance. Values shape how claims are framed and occasionally redirect the line of thought. Some paths pause after comparison rather than being fully followed through.\"\n          },\n          \"charts\": {\n            \"cohort_positioning\": {\n              \"title\": \"Cohort Positioning\",\n              \"help\": \"Horizontal axis shows FRI (0 to 5). Vertical axis shows the share of the cohort (0 to 100%) at each score band. The yellow marker shows the current position, and the outer ring indicates the positioning moment.\",\n              \"curve_points\": [\n                {\n                  \"x\": 0.0,\n                  \"y\": 2\n                },\n                {\n                  \"x\": 0.5,\n                  \"y\": 6\n                },\n                {\n                  \"x\": 1.0,\n                  \"y\": 14\n                },\n                {\n                  \"x\": 1.5,\n                  \"y\": 26\n                },\n                {\n                  \"x\": 2.0,\n                  \"y\": 30\n                },\n                {\n                  \"x\": 2.5,\n                  \"y\": 45\n                },\n                {\n                  \"x\": 3.0,\n                  \"y\": 58\n                },\n                {\n                  \"x\": 3.5,\n                  \"y\": 42\n                },\n                {\n                  \"x\": 4.0,\n                  \"y\": 22\n                },\n                {\n                  \"x\": 4.5,\n                  \"y\": 10\n                },\n                {\n                  \"x\": 5.0,\n                  \"y\": 4\n                }\n              ]\n            },\n            \"rsl_radar\": {\n              \"title\": \"RSL Radar\",\n              \"help\": \"This chart shows balance. A rounder shape means your skills work together. Sharp dips mean one or two skills need attention.\"\n            }\n          },\n          \"dimensions\": [\n            {\n              \"code\": \"R1.\",\n              \"name\": \"Interpretation\",\n              \"score\": 4,\n              \"observation\": \"Interprets the guiding questions by unpacking what the inquiry seeks to examine and why it matters. As a result, the response follows how each question invites reflection on meaning, history, and change rather than surface definition. However one further step could trace how a single constraint narrows that purpose at a specific moment. For example, the meaning of American shifts when political conflict intensifies rather than remaining constant across periods.\"\n            },\n            {\n              \"code\": \"R2.\",\n              \"name\": \"Issue Decomposition\",\n              \"score\": 4,\n              \"observation\": \"Breaks the discussion into linked issues such as history, identity, politics, and literary form. As a result, the reasoning moves by showing how one element leads to or reacts against another across time. One next step could follow one issue through a single cause-and-effect chain without branching. For example, shifts in political climate lead to renewed interest in essays that foreground individual voice.\"\n            },\n            {\n              \"code\": \"R3.\",\n              \"name\": \"Evidence Quality\",\n              \"score\": 3,\n              \"observation\": \"Uses named writers, historical periods, and well-known works as supporting material. As a result, claims are grounded in recognizable examples rather than unsupported assertion. One next step could pause to compare how two sources differ in reliability or reach. For example, a founding-era pamphlet and a contemporary essay serve different audiences and purposes.\"\n            },\n            {\n              \"code\": \"R4.\",\n              \"name\": \"Reasoning & Counterfactuals\",\n              \"score\": 4,\n              \"observation\": \"Explores how ideas might appear differently under alternate historical or political conditions. As a result, the reasoning considers what follows if certain fears, values, or trends dominate at a given time. One next step could hold two possible outcomes side by side before moving on. For example, expanding democratic ideals can coexist with persistent inequality depending on which forces prevail.\"\n            },\n            {\n              \"code\": \"R5.\",\n              \"name\": \"Coherence & Clarity\",\n              \"score\": 4,\n              \"observation\": \"Moves smoothly from personal experience to historical survey and then to present-day observation. As a result, ideas connect through clear transitions that keep the line of thought easy to follow. One next step could linger briefly at a transition point before shifting topics. For example, a pause between early religious writing and Enlightenment argument highlights the change in tone.\"\n            },\n            {\n              \"code\": \"R6.\",\n              \"name\": \"Metacognition & Self-repair\",\n              \"score\": 4,\n              \"observation\": \"Revisits earlier judgments and revises them after new exposure and reflection. As a result, the thinking shows awareness of limits in prior views and adjustment over time. One next step could name a specific trigger that prompted the shift more precisely. For example, encountering authoritarian rule abroad altered assumptions about domestic political risk.\"\n            },\n            {\n              \"code\": \"R7.\",\n              \"name\": \"Ethical / Societal Framing\",\n              \"score\": 4,\n              \"observation\": \"Frames ideas through values such as democracy, freedom, and fairness while acknowledging tension among them. As a result, conclusions shift depending on which value is emphasized at a given moment. One next step could set a clear boundary where one value outweighs another. For example, democratic aspiration loses force when systemic exclusion remains unaddressed.\"\n            },\n            {\n              \"code\": \"R8.\",\n              \"name\": \"Perspective Flexibility\",\n              \"score\": 4,\n              \"observation\": \"Moves between personal, historical, literary, and political viewpoints to reconsider claims. As a result, conclusions change as the vantage point changes across eras and roles. One next step could explicitly contrast two viewpoints before settling on one. For example, a colonial religious outlook contrasts sharply with a secular Enlightenment stance.\"\n            }\n          ],\n          \"alignment_disclosure\": \"RSL (R1\u2013R8) is aligned with internationally validated reasoning constructs used across OECD/PISA assessments, ETS evidence-centered evaluation frameworks, APA-endorsed critical thinking models, and UNESCO-referenced global competence and citizenship frameworks.\"\n        },\n        \"cff\": {\n          \"section_title\": \"2. Cognitive Fingerprint Framework (CFF)\",\n          \"section_lead\": \"Describes structural characteristics of reasoning formation and revision behavior observed in the task, based on the CFF indicator set.\",\n          \"final_determination\": {\n            \"label\": \"Ax-4. Reasoning Simulator\",\n            \"type_confidence\": 0.81,\n            \"lead\": \"Final label is Ax-4. Reasoning Simulator with Type Confidence 0.81 .\",\n            \"explanation\": \"Ax-4. Reasoning Simulator reflects a reasoning structure that appears coherent and well-formed, while transitions and revisions are driven by simulated control patterns rather than direct intent formation.\"\n          },\n          \"observed_patterns\": {\n            \"lead\": \"Primary pattern is Reflective Explorer and secondary pattern is Evidence Weaver , with Type Confidence 0.83 .\",\n            \"primary\": \"Reflective Explorer\",\n            \"secondary\": \"Evidence Weaver\",\n            \"type_confidence\": 0.83,\n            \"explanation\": \"Reflective Explorer shows active self-revision and exploratory restructuring during reasoning. Thought progresses through reflection, reassessment, and adaptive refinement. And Evidence Weaver emphasizes linking claims with supporting material. Reasoning strength lies in evidence connectivity rather than abstract inference.\"\n          },\n          \"signature_fingerprint\": {\n            \"title\": \"Cognitive Fingerprint\",\n            \"subtitle\": \"Reasoning Structure Visualization\",\n            \"description\": \"The Cognitive Fingerprint is a structural identification layer for reasoning. While topics may change, the way a person constructs claims, moves between ideas, and revises conclusions follows a consistent pattern. NeuPrint visualizes this repeatable structure to enable comparison across prompts, domains, and time.\"\n          },\n          \"radar\": {\n            \"title\": \"CFF Radar\",\n            \"help\": \"The CFF Radar shows the relative distribution of structural reasoning indicators. The shape reflects contribution patterns rather than performance or optimality.\"\n          },\n          \"indicator_summary\": {\n            \"rows\": [\n              {\n                \"code\": \"AAS\",\n                \"indicator\": \"Argument Architecture Style\",\n                \"score\": 0.63,\n                \"status\": \"Active\"\n              },\n              {\n                \"code\": \"CTF\",\n                \"indicator\": \"Cognitive Transition Flow\",\n                \"score\": 0.71,\n                \"status\": \"Active\"\n              },\n              {\n                \"code\": \"RMD\",\n                \"indicator\": \"Reasoning Momentum Delta\",\n                \"score\": 0.58,\n                \"status\": \"Active\"\n              },\n              {\n                \"code\": \"RDX\",\n                \"indicator\": \"Revision Depth Index\",\n                \"score\": 0.74,\n                \"status\": \"Active\"\n              },\n              {\n                \"code\": \"EDS\",\n                \"indicator\": \"Evidence Diversity Score\",\n                \"score\": 0.62,\n                \"status\": \"Active\"\n              },\n              {\n                \"code\": \"IFD\",\n                \"indicator\": \"Intent Friction Delta\",\n                \"score\": 0.33,\n                \"status\": \"Active\"\n              },\n              {\n                \"code\": \"KPF-Sim\",\n                \"indicator\": \"Keystroke Pattern Fingerprint Similarity\",\n                \"score\": null,\n                \"status\": \"Excluded\"\n              },\n              {\n                \"code\": \"TPS-H\",\n                \"indicator\": \"Thought Pattern Similarity (History-based)\",\n                \"score\": null,\n                \"status\": \"Excluded\"\n              }\n            ],\n            \"closing\": \"The Cognitive Fingerprint Framework describes how reasoning is structurally formed, revised, and controlled, providing a stable reference for understanding thinking patterns beyond surface content or outcomes.\"\n          },\n          \"indicators\": {\n            \"AAS\": 0.63,\n            \"CTF\": 0.71,\n            \"RMD\": 0.58,\n            \"RDX\": 0.74,\n            \"EDS\": 0.62,\n            \"IFD\": 0.33,\n            \"KPF-Sim\": null,\n            \"TPS-H\": null\n          }\n        },\n        \"agency\": {\n          \"section_title\": \"3. Reasoning Control (Structural Agency)\",\n          \"section_lead\": \"Evaluates individual control over reasoning decisions versus automated continuation, as defined by structural agency at decision boundaries in NeuPrint.\",\n          \"summary\": {\n            \"title\": \"Reasoning Control Summary\",\n            \"headline\": \"Human-led reasoning with stable structural traces. Current point is near the human cluster center.\",\n            \"control_pattern\": \"deep_reflective_human\",\n            \"reliability_band\": \"HIGH\",\n            \"decision_statement\": \"Reasoning decisions originate from human-driven structural revision rather than automated continuation flow.\"\n          },\n          \"observed_structural_signals\": {\n            \"title\": \"Observed Structural Signals\",\n            \"bullets\": [\n              \"Revision activity occurs at semantic decision boundaries.\",\n              \"Argument order adjustments correspond to logical correction.\",\n              \"Consistency checks appear across structural transitions.\",\n              \"No sustained automated propagation is detected at reasoning boundaries.\"\n            ],\n            \"note\": \"These signals reflect document-specific structural behavior and are independent of surface-level writing style.\"\n          },\n          \"distribution\": {\n            \"title\": \"Reasoning Control Distribution\",\n            \"help\": \"The distribution shows the proportion of ownership of reasoning decisions across structural decision points. Values reflect where control was exercised during reasoning transitions, not authorship attribution, model usage, or stylistic origin. A high human proportion indicates that primary reasoning control remained with the individual throughout the task.\",\n            \"human_pct\": 82,\n            \"hybrid_pct\": 9,\n            \"ai_pct\": 9\n          },\n          \"signals\": {\n            \"title\": \"Structural Control Signals (Agency Indicators)\",\n            \"help\": \"Signal values represent relative contribution to the overall reasoning control determination, normalized on a 0 to 1 scale.\",\n            \"items\": [\n              {\n                \"label\": \"Structural variance\",\n                \"note\": \"non-linear restructuring across reasoning boundaries.\"\n              },\n              {\n                \"label\": \"Human rhythm index\",\n                \"note\": \"irregular pacing consistent with reflective decision cycles.\"\n              },\n              {\n                \"label\": \"Transition flow\",\n                \"note\": \"intentional movement between reasoning states.\"\n              },\n              {\n                \"label\": \"Revision depth\",\n                \"note\": \"degree of conceptual modification at semantic boundaries.\"\n              }\n            ],\n            \"conclusion\": \"The combined signal profile supports classification as human-controlled reasoning.\",\n            \"contributions\": {\n              \"structural_variance\": 0.22,\n              \"human_rhythm_index\": 0.18,\n              \"transition_flow\": 0.15,\n              \"revision_depth\": 0.12\n            }\n          },\n          \"signal_contributions\": {\n            \"structural_variance\": 0.22,\n            \"human_rhythm_index\": 0.18,\n            \"transition_flow\": 0.15,\n            \"revision_depth\": 0.12\n          }\n        },\n        \"role_fit\": {\n          \"section_title\": \"4. Role Fit Signals\",\n          \"section_lead\": \"Explores alignment between observed reasoning patterns and role-specific cognitive demands.\",\n          \"cognitive_style_summary\": \"Reflective Explorer, structured but exploratory. Recommended roles include: Analyst, Research, Strategy.\",\n          \"track_scores\": [\n            {\n              \"track\": \"Strategy\u00b7Analysis\u00b7Policy\",\n              \"pct\": 78\n            },\n            {\n              \"track\": \"Data\u00b7AI\u00b7Intelligence\",\n              \"pct\": 74\n            }\n          ],\n          \"profile_statement\": \"This profile indicates consistent evidence of structured reasoning, hypothesis exploration, and deliberate evaluation patterns, which align with roles requiring analytical depth, research-driven inquiry, and strategic framing.\",\n          \"job_role_fit\": [\n            {\n              \"track\": \"Strategy\u00b7Analysis\u00b7Policy\",\n              \"roles\": [\n                \"Strategy Analyst\",\n                \"Management Analyst\",\n                \"Policy Analyst\",\n                \"Economic Researcher\",\n                \"Financial Analyst\",\n                \"Risk Analyst\",\n                \"Compliance Officer\",\n                \"Internal Auditor\"\n              ]\n            },\n            {\n              \"track\": \"Data\u00b7AI\u00b7Intelligence\",\n              \"roles\": [\n                \"Data Analyst\",\n                \"Data Scientist\",\n                \"Business Intelligence Analyst\",\n                \"Machine Learning Analyst\",\n                \"Statistician\",\n                \"Operations Research Analyst\",\n                \"Information Security Analyst\"\n              ]\n            }\n          ],\n          \"inference_flow\": {\n            \"title\": \"Role Fit Inference Flow\",\n            \"items\": [\n              {\n                \"title\": \"Cognitive Operating Characteristics\",\n                \"tags\": \"thought control \u00b7 reasoning mode\"\n              },\n              {\n                \"title\": \"Reasoning Structure Patterns\",\n                \"tags\": \"decomposition \u00b7 linkage \u00b7 validation \u00b7 regulation\"\n              },\n              {\n                \"title\": \"NeuPrint Primary Metrics\",\n                \"tags\": \"CFF Prime 8 \u00b7 RSL R1\u2013R8\"\n              },\n              {\n                \"title\": \"NeuPrint Secondary Interpretations\",\n                \"tags\": \"Reasoning Level \u00b7 Stability \u00b7 Drift\"\n              },\n              {\n                \"title\": \"Competency Fulfillment Assessment\",\n                \"tags\": \"OECD aligned \u00b7 O*NET aligned \u00b7 reference\"\n              },\n              {\n                \"title\": \"Job Role Fit\",\n                \"tags\": \"final alignment signal \u00b7 decision support\"\n              }\n            ],\n            \"closing\": \"NeuPrint measures reasoning structures, derives interpretable cognitive profiles, and aligns them with internationally recognized competency frameworks (OECD and O*NET) to inform job role fit.\"\n          }\n        },\n        \"footer\": {\n          \"logos\": [\n            \"OECD\",\n            \"PISA\",\n            \"ETS\",\n            \"APA\",\n            \"O*NET\",\n            \"AERA\",\n            \"NCME\",\n            \"AAC&U\",\n            \"Cambridge\",\n            \"IB\",\n            \"LSAT\",\n            \"GMAT\"\n          ],\n          \"alignment_paragraphs\": [\n            \"NeuPrint\u2019s cognitive frameworks and rubrics are structurally aligned with internationally recognized assessment and competency systems .\",\n            \"These include OECD PISA , ETS measurement models , AERA and NCME evaluation standards , and AAC&U VALUE rubrics .\",\n            \"They also reflect shared reasoning constructs found in Cambridge International , the International Baccalaureate (IB) , and reasoning assessments such as the LSAT and GMAT .\"\n          ],\n          \"copyright\": \"Copyright \u00a9 2026 Neuprint. All rights reserved.\",\n          \"entity_note\": \"U.S. entity in formation.\"\n        },\n        \"ai\": {\n          \"mix_ratio\": {\n            \"human\": 0.82,\n            \"hybrid\": 0.09,\n            \"ai\": 0.09\n          },\n          \"signal_contributions\": {\n            \"structural_variance\": 0.22,\n            \"human_rhythm_index\": 0.18,\n            \"transition_flow\": 0.15,\n            \"revision_depth\": 0.12\n          },\n          \"interpretation\": \"Human-led reasoning with stable structural traces. Current point is near the human cluster center.\",\n          \"pattern_label\": \"deep_reflective_human\",\n          \"detection_reliability_band\": \"HIGH\"\n        }\n      }\n    </textarea>\n\n\n</div>\n" }),
    []
  );

  useEffect(() => {
    const root = document.documentElement;

    // ensure scope class is active and others removed
    root.classList.remove("npHome-scope");
    root.classList.add("npReport-scope");

    // run the original inline script logic (loads Chart.js dynamically)
    try {
      runReportV3();
    } catch (_e) {
      // no-op: page should still render base HTML even if script fails
    }

    return () => {
      root.classList.remove("npReport-scope");
    };
  }, []);

  return <div dangerouslySetInnerHTML={reportHtml} />;
}
